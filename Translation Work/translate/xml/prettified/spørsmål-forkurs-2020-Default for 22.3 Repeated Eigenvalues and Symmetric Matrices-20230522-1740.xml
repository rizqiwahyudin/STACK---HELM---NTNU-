<quiz>
    <!-- question: 0  -->
    <question type="category">
        <category>
            <text>$module$/top/Default for 22.3 Repeated Eigenvalues and Symmetric Matrices</text>
        </category>
        <info format="moodle_auto_format">
            <text>The default category for questions shared in context '22.3 Repeated Eigenvalues and Symmetric Matrices'.</text>
        </info>
        <idnumber></idnumber>
    </question>
    <!-- question: 9123  -->
    <question type="description">
        <name>
            <text>22.3.1.1 Matrices with repeated eigenvalues</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<h3>
    <span class="multilang" lang="en">
        Matrices with repeated eigenvalues
    </span>
    <span class="multilang" lang="no">
        Matriser med gjentatte egenverdier
    </span>
</h3>
<p>
    <span class="multilang" lang="en">
        So far we have considered the diagonalization of matrices with distinct (i.e. non-repeated) eigenvalues. We have accomplished this by the use of a
        <strong>
            non-singular
        </strong>
        modal matrix \(P\) (i.e. one where \(\det P\neq 0\) and hence the inverse \(P^{-1}\) exists). We now want to discuss briefly the case of a matrix \(A\) with at least one pair of
        <strong>
            repeated eigenvalues
        </strong>
        . We shall see that for some such matrices diagonalization is possible but for others it is not.
    </span>
    <span class="multilang" lang="no">
        Så langt har vi vurdert diagonalisering av matriser med ulike (dvs. ikke-gjentatte) egneverdier. Vi har oppnådd dette ved å bruke en
        <strong>
            ikke-singulær
        </strong>
        modal-matrise \(P\) (dvs. der \(\det P \neq 0\) og den inverse \(P^{-1}\) eksisterer). Vi ønsker nå kort å diskutere tilfellet av en matrise \(A\) med minst ett par
        <strong>
            gjentatte egneverdier
        </strong>
        . Vi skal se at for noen slike matriser er diagonalisering mulig, men for andre er det ikke mulig.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        The crucial question is whether we can form a non-singular modal matrix \(P\) with the eigenvectors of \(A\) as its columns.
    </span>
    <span class="multilang" lang="no">
        Det avgjørende spørsmålet er om vi kan danne en ikke-singulær modal matrise \(P\) med egenvektorene til \(A\) som dens kolonner.
    </span>
</p>
<hr/>
<h4 class="HELM_example">
    <span class="multilang" lang="en">
        Example
    </span>
    <span class="multilang" lang="no">
        Eksempel
    </span>
</h4>
<p>
    <span class="multilang" lang="en">
        Consider the matrix
                \[ A=\left[\begin{array}{rc}1&amp;0\\ -4&amp;1\end{array}\right]\]
                which has characteristic equation
                \[ \det (A-\lambda I)=(1-\lambda)(1-\lambda)=0.\]
                So the only eigenvalue is \(1\) which is repeated or, more formally, has
        <strong>
            multiplicity
        </strong>
        2.
    </span>
    <span class="multilang" lang="no">
        Vi ser på matrisen
                                \[ A=\left[\begin{array}{rc}1&amp;0\\ -4&amp;1\end{array}\right]\]
                                som har den karakteristiske likningen
                                \[ \det (A-\lambda I)=(1-\lambda)(1-\lambda)=0.\]
                                Så den eneste egneverdien er \(1\) som er gjentatt eller, mer formelt, har
        <strong>
            multiplisitet
        </strong>
        2.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        To obtain eigenvectors of \(A\) corresponding to \(\lambda=1\) we proceed as usual and solve
                \[ AX=1X\]
                or
                \[ \left[\begin{array}{rc}1&amp;0\\ -4&amp;1\end{array}\right]\left[\begin{array}{c} x\\ y\end{array}\right]= \left[\begin{array}{c}x\\ y\end{array}\right]\]
                implying
                \[ x=x\qquad \text{and} \qquad -4x+y=y\]
                from which \(x=0\) and \(y\) is arbitrary.
    </span>
    <span class="multilang" lang="no">
        For å få egenvektorer til \(A\) som svarer til \(\lambda=1\) gjør vi som vanlig og løser
                                \[ AX=1X\]
                                eller
                                \[ \left[\begin{array}{rc}1&amp;0\\ -4&amp;1\end{array}\right]\left[\begin{array}{c} x\\ y\end{array}\right]= \left[\begin{array}{c}x\\ y\end{array}\right]\]
                                som gir
                                \[ x=x\qquad \text{og} \qquad -4x+y=y\]
                                fra hvilket \(x=0\) og \(y\) er vilkårlig.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Thus possible eigenvectors are \(\qquad \left[\begin{array}{r}0\\-1\end{array}\right],\quad \left[\begin{array}{c}0\\ 1\end{array}\right],\quad \left[\begin{array}{c}0\\ 2\end{array}\right],\quad \left[\begin{array}{c}0\\ 3\end{array}\right]\quad\dots\)
    </span>
    <span class="multilang" lang="no">
        Så mulige egenvektorer er \(\qquad \left[\begin{array}{r}0\\-1\end{array}\right],\quad \left[\begin{array}{c}0\\ 1\end{array}\right],\quad \left[\begin{array}{c}0\\ 2\end{array}\right],\quad \left[\begin{array}{c}0\\ 3\end{array}\right]\quad\dots\)
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        However, if we attempt to form a modal matrix \(P\) from any two of these eigenvectors, e.g. \(\left[\begin{array}{r}0\\-1\end{array}\right]\) and \(\left[\begin{array}{c}0\\1\end{array}\right]\) then the resulting matrix \(P=\left[\begin{array}{rc}0&amp;0\\ -1&amp;1\end{array}\right]\) has
        <strong>
            zero
        </strong>
        determinant.
    </span>
    <span class="multilang" lang="no">
        Men hvis vi prøver å danne en modal matrise \(P\) fra noen av disse egenvektorene, f.eks. \(\left[\begin{array}{r}0\\-1\end{array}\right]\) og \(\left[\begin{array}{c}0\\1\end{array}\right]\) så har den resulterende matrisen \(P=\left[\begin{array}{rc}0&amp;0\\ -1&amp;1\end{array}\right]\)
        <strong>
            null
        </strong>
        determinant.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Thus \(P^{-1}\)
        <strong>
            does not exist
        </strong>
        and the similarity transformation \(P^{-1}AP\) that we have used previously to diagonalize a matrix is not possible here. The essential point, at a slightly deeper level, is that the columns of \(P\) in this case are
        <strong>
            not linearly independent
        </strong>
        since
                \[ \left[\begin{array}{r}0\\ -1\end{array}\right]=(-1)\left[\begin{array}{c}0\\ 1\end{array}\right]\]
                i.e. one is a multiple of the other.
    </span>
    <span class="multilang" lang="no">
        Så \(P^{-1}\)
        <strong>
            eksisterer ikke
        </strong>
        og likhetstransformasjonen \(P^{-1}AP\) som vi har brukt tidligere for å diagonalisere en matrise er ikke mulig her. Det essensielle punktet, på et litt dypere nivå, er at kolonnene i \(P\) i dette tilfellet
        <strong>
            ikke er lineært uavhengige
        </strong>
        siden
                                \[ \left[\begin{array}{r}0\\ -1\end{array}\right]=(-1)\left[\begin{array}{c}0\\ 1\end{array}\right]\]
                                dvs. en er en multiplikasjon av den andre.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        This situation is to be contrasted with that of a matrix with non-repeated eigenvalues. Earlier, for example, we showed that the matrix
                \[ A=\left[\begin{array}{cc}2&amp;3\\ 3&amp;2\end{array}\right]\]
                has the non-repeated eigenvalues \(\lambda_1=-1,\ \lambda_2=5\) with associated eigenvectors
                \[ X_1=\left[\begin{array}{r}1\\-1\end{array}\right]\qquad\qquad X_2=\left[\begin{array}{c}1\\ 1\end{array}\right].\]
                These two eigenvectors
        <strong>
            are linearly independent
        </strong>
        ,
                since \(\left[\begin{array}{r}1\\-1\end{array}\right]\neq k\ \left[\begin{array}{c}1\\1\end{array}\right]\) for any value of \(k\ne 0\).
    </span>
    <span class="multilang" lang="no">
        Denne situasjonen er i kontrast til en matrise med ikke-gjentatte egenverdier. Tidligere, for eksempel, viste vi at matrisen
                                \[ A=\left[\begin{array}{cc}2&amp;3\\ 3&amp;2\end{array}\right]\]
                                har de ikke-gjentatte egenverdiene \(\lambda_1=-1,\ \lambda_2=5\) med tilhørende egenvektorer
                                \[ X_1=\left[\begin{array}{r}1\\-1\end{array}\right]\qquad\qquad X_2=\left[\begin{array}{c}1\\ 1\end{array}\right].\]
                                Disse to egenvektorene
        <strong>
            er lineært uavhengige
        </strong>
        ,
                                siden \(\left[\begin{array}{r}1\\-1\end{array}\right]\neq k\ \left[\begin{array}{c}1\\1\end{array}\right]\) for noen verdi av \(k\ne 0\).
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Here the modal matrix
                \[ P=\left[\begin{array}{rc}1&amp;1\\ -1&amp;1\end{array}\right]\]
                has linearly independent columns: so that \(\det P\neq 0\) and \(P^{-1}\) exists.
    </span>
    <span class="multilang" lang="no">
        Her har modal matrisen
                                \[ P=\left[\begin{array}{rc}1&amp;1\\ -1&amp;1\end{array}\right]\]
                                lineært uavhengige kolonner: så \(\det P\neq 0\) og \(P^{-1}\) eksisterer.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        The general result, illustrated by this example, is given in the following Key Point.
    </span>
    <span class="multilang" lang="no">
        Det generelle resultatet, illustrert av dette eksemplet, gis i følgende nøkkelpunkt.
    </span>
</p>
<div class="HELM_keypoint">
    <h4>
        <span class="multilang" lang="en">
            Key Point
        </span>
        <span class="multilang" lang="no">
            Nøkkelpunkt
        </span>
    </h4>
    <p>
        <span class="multilang" lang="en">
            Eigenvectors corresponding to distinct eigenvalues are always linearly independent.
        </span>
        <span class="multilang" lang="no">
            Egenvektorer som tilhører ulike egenverdier er alltid lineært uavhengige.
        </span>
    </p>
</div>
<p>
    <span class="multilang" lang="en">
        It follows from this that we can
        <strong>
            always
        </strong>
        diagonalize an \(n\times n\) matrix with \(n\)
        <strong>
            distinct
        </strong>
        eigenvalues since it will possess \(n\) linearly independent eigenvectors. We can then use these as the columns of \(P\), secure in the knowledge that these columns will be linearly independent and hence \(P^{-1}\) will exist. It follows, in considering the case of repeated eigenvalues, that the key problem is whether or not there are still \(n\) linearly independent eigenvectors for an \(n\times n\) matrix.
    </span>
    <span class="multilang" lang="no">
        Dette følger av at vi
        <strong>
            alltid
        </strong>
        kan diagonalisere en \(n\times n\) matrise med \(n\)
        <strong>
            ulike
        </strong>
        egenverdier siden den vil ha \(n\) lineært uavhengige egenvektorer. Vi kan deretter bruke disse som kolonnene i \(P\), trygt med kunnskapen om at disse kolonnene vil være lineært uavhengige og dermed eksisterer \(P^{-1}\). Det følger, ved å vurdere tilfellet med gjentatte egenverdier, at det viktigste problemet er om det fortsatt er \(n\) lineært uavhengige egenvektorer for en \(n\times n\) matrise.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        We shall now consider two \(3\times 3\) cases as illustrations.
    </span>
    <span class="multilang" lang="no">
        Vi skal nå vurdere to \(3\times 3\) tilfeller som illustrasjoner.
    </span>
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9124  -->
    <question type="description">
        <name>
            <text>22.3.1.4 Final key point</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<div class="HELM_keypoint">
    <h4>
        <span class="multilang" lang="en">
            Key Point
        </span>
        <span class="multilang" lang="no">
            Nøkkelpunkt
        </span>
    </h4>
    <p>
        <span class="multilang" lang="en">
            An \(n\times n\) matrix with repeated eigenvalues can be diagonalized provided we can obtain \(n\) linearly independent eigenvectors for it. This will be the case if, for each repeated eigenvalue \(\lambda_i\), of multiplicity \(m_i&gt;1\), we can obtain \(m_i\) linearly independent eigenvectors.
        </span>
        <span class="multilang" lang="no">
            En \(n\times n\) matrise med gjentatte egenverdier kan diagonaliseres dersom vi kan finne \(n\) lineært uavhengige egenvektorer for den. Dette vil være tilfellet hvis, for hver gjentatte egenverdien \(\lambda_i\), med multiplicitet \(m_i&gt;1\), vi kan finne \(m_i\) lineært uavhengige egenvektorer.
        </span>
    </p>
</div>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9125  -->
    <question type="description">
        <name>
            <text>22.3.2.1 Symmetric matrices</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<h3>
    <span class="multilang" lang="en">
        Symmetric matrices
    </span>
    <span class="multilang" lang="no">
        Symmetriske matriser
    </span>
</h3>
<p>
    <span class="multilang" lang="en">
        Symmetric matrices have a number of useful properties which we will investigate in this Section.
    </span>
    <span class="multilang" lang="no">
        Symmetriske matriser har en rekke nyttige egenskaper som vi skal undersøke i denne seksjonen.
    </span>
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9130  -->
    <question type="description">
        <name>
            <text>22.3.2.10 Diagonalization of symmetric matrices</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<h4>
    <span class="multilang" lang="en">
        Diagonalization of symmetric matrices
    </span>
    <span class="multilang" lang="no">
        Diagonalisering av symmetriske matriser
    </span>
</h4>
<p>
    <span class="multilang" lang="en">
        Recall from our earlier work that
    </span>
    <span class="multilang" lang="no">
        Husk fra tidligere arbeid at
    </span>
</p>
<ol>
    <li>
        <span class="multilang" lang="en">
            We can
            <strong>
                always
            </strong>
            diagonalize a matrix with distinct eigenvalues (whether these are real or complex).
        </span>
        <span class="multilang" lang="no">
            Vi kan
            <strong>
                alltid
            </strong>
            diagonalisere en matrise med ulike egenverdier (uansett om disse er reelle eller komplekse).
        </span>
    </li>
    <li>
        <span class="multilang" lang="en">
            We can
            <strong>
                sometimes
            </strong>
            diagonalize a matrix with repeated eigenvalues. (The condition for this to be possible is that any eigenvalue of multiplicity \(m\) had to have associated with it \(m\) linearly independent eigenvectors.)
        </span>
        <span class="multilang" lang="no">
            Vi kan
            <strong>
                noen ganger
            </strong>
            diagonalisere en matrise med like egenverdier. (Betingelsen for at dette skal være mulig er at en egenverdi av multiplicitet \(m\) måtte ha vært assosiert med \(m\) lineært uavhengige egenvektorer.)
        </span>
    </li>
</ol>
<p>
    <span class="multilang" lang="en">
        The situation with symmetric matrices is simpler. Basically we can diagonalize
        <strong>
            any
        </strong>
        symmetric matrix. To take the discussions further we first need the concept of an
        <strong>
            orthogonal
        </strong>
        matrix.
    </span>
    <span class="multilang" lang="no">
        Situasjonen med symmetriske matriser er enklere. I bunn og grunn kan vi diagonalisere
        <strong>
            enhver
        </strong>
        symmetrisk matrise. For å ta diskusjonene videre trenger vi først begrepet om en
        <strong>
            ortogonal
        </strong>
        matrise.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        A square matrix \(A\) is said to be orthogonal if its inverse (if it exists) is equal to its transpose: \[A^{-1}=A^T \qquad \text{or, equivalently,}\qquad AA^T=A^TA=I.\]
    </span>
    <span class="multilang" lang="no">
        En kvadratisk matrise \(A\) sies å være ortogonal hvis dens inverse (hvis den eksisterer) er lik dens transponerte: \[A^{-1}=A^T \qquad \text{eller, tilsvarende,}\qquad AA^T=A^TA=I.\]
    </span>
</p>
<hr/>
<h4 class="HELM_example">
    <span class="multilang" lang="en">
        Example
    </span>
    <span class="multilang" lang="no">
        Eksempel
    </span>
</h4>
<p>
    <span class="multilang" lang="en">
        An important example of an orthogonal matrix is \[A=\left[\begin{array}{rc}\cos\phi&amp;\sin\phi\\ -\sin\phi&amp;\cos\phi\end{array}\right]\] which arises when we use matrices to describe rotations in a plane. \[\begin{aligned} AA^T&amp;=\left[\begin{array}{rc}\cos\phi&amp;\sin\phi\\
                -\sin\phi&amp;\cos\phi\end{array}\right]\left[\begin{array}{cr}\cos\phi&amp;-\sin\phi \\ \sin\phi&amp;\cos\phi\end{array}\right]\\ \\ &amp;=\left[\begin{array}{cc}\cos^2\phi+\sin^{2}\phi&amp;0\\ 0&amp;\sin^2\phi+\cos^2\phi\end{array}\right]=\left[\begin{array}{cc}1&amp;0\\
                0&amp;1\end{array}\right]=I\qquad\qquad\qquad\qquad\qquad\quad\end{aligned}\] It is clear that \(A^TA=I\) also, so \(A\) is indeed orthogonal.
    </span>
    <span class="multilang" lang="no">
        Et viktig eksempel på en ortogonal matrise er \[A=\left[\begin{array}{rc}\cos\phi&amp;\sin\phi\\ -\sin\phi&amp;\cos\phi\end{array}\right]\] som oppstår når vi bruker matriser til å beskrive rotasjoner i et plan. \[\begin{aligned} AA^T&amp;=\left[\begin{array}{rc}\cos\phi&amp;\sin\phi\\
                -\sin\phi&amp;\cos\phi\end{array}\right]\left[\begin{array}{cr}\cos\phi&amp;-\sin\phi \\ \sin\phi&amp;\cos\phi\end{array}\right]\\ \\ &amp;=\left[\begin{array}{cc}\cos^2\phi+\sin^{2}\phi&amp;0\\ 0&amp;\sin^2\phi+\cos^2\phi\end{array}\right]=\left[\begin{array}{cc}1&amp;0\\
                0&amp;1\end{array}\right]=I\qquad\qquad\qquad\qquad\qquad\quad\end{aligned}\] Det er klart at \(A^TA=I\) også, så \(A\) er faktisk ortogonal.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        It can be shown, but we omit the details, that any \(2\times 2\) matrix which is orthogonal can be written in one of the two forms: \[\left[\begin{array}{rc}\cos\phi&amp;\sin\phi\\ -\sin\phi&amp;\cos\phi\end{array}\right]\qquad\text{or}\qquad \left[\begin{array}{cc}\cos\phi&amp;-\sin\phi\\\sin\phi&amp;\cos\phi\end{array}\right].\]
                If we look closely at either of these matrices we can see that
    </span>
    <span class="multilang" lang="no">
        Det kan bli vist, men vi unnlater detaljene, at enhver \(2\times 2\) matrise som er ortogonal kan skrives i en av de to formene: \[\left[\begin{array}{rc}\cos\phi&amp;\sin\phi\\ -\sin\phi&amp;\cos\phi\end{array}\right]\qquad\text{eller}\qquad \left[\begin{array}{cc}\cos\phi&amp;-\sin\phi\\\sin\phi&amp;\cos\phi\end{array}\right].\]
                                Hvis vi ser nøye på en av disse matrisene kan vi se at
    </span>
</p>
<ol>
    <li>
        <span class="multilang" lang="en">
            The two columns are mutually orthogonal e.g. for the first matrix we have \[\left[\cos\phi\quad -\sin\phi\right]\left[\begin{array}{c}\sin\phi\\ \cos\phi\end{array}\right]=\cos\phi\sin\phi-\sin\phi\cos\phi=0.\]
        </span>
        <span class="multilang" lang="no">
            De to kolonnene er ortogonale, dvs. for den første matrisen har vi \[\left[\cos\phi\quad -\sin\phi\right]\left[\begin{array}{c}\sin\phi\\ \cos\phi\end{array}\right]=\cos\phi\sin\phi-\sin\phi\cos\phi=0.\]
        </span>
    </li>
    <li>
        <span class="multilang" lang="en">
            Each column has magnitude \(1\) (because \(\sqrt{\cos^2\phi+\sin^2\phi}=1)\).
        </span>
        <span class="multilang" lang="no">
            Hver kolonne har størrelse \(1\) (fordi \(\sqrt{\cos^2\phi+\sin^2\phi}=1)\).
        </span>
    </li>
</ol>
<p>
    <span class="multilang" lang="en">
        Although we shall not prove it, these results are necessary and sufficient for any order square matrix to be orthogonal.
    </span>
    <span class="multilang" lang="no">
        Selv om vi ikke skal bevise det, er disse resultatene nødvendige og tilstrekkelige for at en kvadratisk matrise av hvilken seom helst orden skal være ortogonal.
    </span>
</p>
<hr/>
<div class="HELM_keypoint">
    <h4>
        <span class="multilang" lang="en">
            Key Point
        </span>
        <span class="multilang" lang="no">
            Nøllpunkt
        </span>
    </h4>
    <p>
        <span class="multilang" lang="en">
            A square matrix \(A\) is said to be orthogonal, if its inverse (if it exists) is equal to its transpose: \[A^{-1} = A^T\] or, equivalently, \[AA^T=A^TA=I.\] A square matrix is orthogonal if and only if its columns are mutually orthogonal and each
                                column has unit magnitude.
        </span>
        <span class="multilang" lang="no">
            En kvadratisk matrise \(A\) sies å være ortogonal hvis dens inverse (hvis den eksisterer) er lik dens transponerte: \[A^{-1} = A^T\] eller, tilsvarende, \[AA^T=A^TA=I.\] En kvadratisk matrise er ortogonal hvis og bare hvis dens kolonner er ortogonale og hver kolonne har enhetsstørrelse.
        </span>
    </p>
</div>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9131  -->
    <question type="description">
        <name>
            <text>22.3.2.12 Symmetric matrices are orthogonally diagonalizable</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The following is the key result of this Section.
    </span>
    <span class="multilang" lang="no">
        Følgende er hovedresultatet til seksjonen.
    </span>
</p>
<div class="HELM_keypoint">
    <h4>
        <span class="multilang" lang="en">
            Key Point
        </span>
        <span class="multilang" lang="no">
            Nøkkelpunkt
        </span>
    </h4>
    <p>
        <span class="multilang" lang="en">
            <strong>
                Any
            </strong>
            symmetric matrix \(A\) can be diagonalized using an orthogonal modal matrix \(P\) via the transformation
                                \[ P^TAP = D = \left[\begin{array}{cccc}\lambda_1 &amp; 0 &amp; \cdots &amp; 0\\ 0 &amp; \lambda_2 &amp; \cdots &amp; 0\\ \vdots &amp; \vdots &amp; \ddots &amp; \\ 0 &amp; 0 &amp; &amp; \lambda_n\end{array}\right]. \]
                                It follows that any \(n\times n\) symmetric matrix
            <strong>
                must
            </strong>
            possess \(n\) mutually orthogonal eigenvectors
            <strong>
                even if some of the eigenvalues are repeated
            </strong>
            .
        </span>
        <span class="multilang" lang="no">
            <strong>
                Enhver
            </strong>
            symmetrisk matrise \(A\) kan diagonaliseres ved hjelp av en ortogonal modal matrise \(P\) via transformasjonen
                                                \[ P^TAP = D = \left[\begin{array}{cccc}\lambda_1 &amp; 0 &amp; \cdots &amp; 0\\ 0 &amp; \lambda_2 &amp; \cdots &amp; 0\\ \vdots &amp; \vdots &amp; \ddots &amp; \\ 0 &amp; 0 &amp; &amp; \lambda_n\end{array}\right]. \]
                                                Det følger at enhver \(n\times n\) symmetrisk matrise
            <strong>
                må
            </strong>
            ha \(n\) ortogonale egenvektorer
            <strong>
                selv om noen av egenverdiene er like
            </strong>
            .
        </span>
    </p>
</div>
<p>
    <span class="multilang" lang="en">
        It should be clear to the reader that the above Key Point is a very powerful result for any applications that involve diagonalization of a symmetric matrix. Further, if we do need to find the inverse of \(P\), then this is a trivial process since \(P^{-1}=P^T\) (the previous Key Point).
    </span>
    <span class="multilang" lang="no">
        Det bør være klart for leseren at ovenstående nøkkelpunkt er et svært kraftig resultat for alle applikasjoner som involverer diagonalisering av en symmetrisk matrise. Videre, hvis vi trenger å finne inversen til \(P\), så er dette en enkel prosess siden \(P^{-1}=P^T\) (det forrige nøkkelpunktet).
    </span>
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9132  -->
    <question type="description">
        <name>
            <text>22.3.2.14 Hermitian matrices</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<h4>
    <span class="multilang" lang="en">
        Hermitian matrices
    </span>
    <span class="multilang" lang="no">
        Hermiteske matriser
    </span>
</h4>
<p>
    <span class="multilang" lang="en">
        In some applications, of which quantum mechanics is one, matrices with
        <strong>
            complex
        </strong>
        elements arise.
    </span>
    <span class="multilang" lang="no">
        I noen anvendelser, hvorav kvantemekanikk er en, oppstår matriser med kompleks elementer.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        If \(A\) is such a matrix then the matrix \(\overline{A}^T\) is the
        <strong>
            conjugate transpose
        </strong>
        of \(A\), i.e. the complex conjugate of each element of \(A\) is taken as well as \(A\) being transposed. Thus if
                \[ A=\left[\begin{array}{cc}2+\mathrm{i}&amp;2\\ 3\mathrm{i}&amp;5-2\mathrm{i}\end{array}\right]\]
                then
                \[ \overline{A}^T=\left[\begin{array}{cc}2-\mathrm{i}&amp;-3\mathrm{i}\\ 2&amp;5+2\mathrm{i}\end{array}\right].\]
                An
        <strong>
            Hermitian
        </strong>
        matrix is one satisfying
                \[ \overline{A}^T=A.\]
                The matrix \(A\) above is clearly non-Hermitian. Indeed the most obvious feature of an Hermitian matrix is that its diagonal elements
        <strong>
            must
        </strong>
        be real. (Can you see why?) Thus
                \[ A=\left[\begin{array}{cc}6&amp;4+\mathrm{i}\\ 4-\mathrm{i}&amp;-2\end{array}\right]\]
                is Hermitian.
    </span>
    <span class="multilang" lang="no">
        Hvis \(A\) er en slik matrise, er matrisen \(\overline{A}^T\)
        <strong>
            konjugattransponeringen
        </strong>
        av \(A\), dvs. kompleks konjugering av hvert element i \(A\) blir tatt i tillegg til at \(A\) transponeres. Så hvis
                \[ A=\left[\begin{array}{cc}2+\mathrm{i}&amp;2\\ 3\mathrm{i}&amp;5-2\mathrm{i}\end{array}\right]\]
                er
                \[ \overline{A}^T=\left[\begin{array}{cc}2-\mathrm{i}&amp;-3\mathrm{i}\\ 2&amp;5+2\mathrm{i}\end{array}\right].\]
                En
        <strong>
            hermitisk
        </strong>
        matrise er en som oppfyller
\[ \overline{A}^T=A.\]
Matrisen \(A\) over er klart ikke-hermitisk. Det mest åpenbare trekket ved en hermitisk matrise er faktisk at dens diagonale elementer
        <strong>
            må
        </strong>
        være reelle. (Kan du se hvorfor?) Derfor er
\[ A=\left[\begin{array}{cc}6&amp;4+\mathrm{i}\\ 4-\mathrm{i}&amp;-2\end{array}\right]\]
hermitisk.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        A \(3\times 3\) example of an Hermitian matrix is
                \[ A=\left[\begin{array}{ccc}1&amp;\mathrm{i}&amp;5-2\mathrm{i}\\ -\mathrm{i}&amp;3&amp;0\\ 5+2\mathrm{i}&amp;0&amp;2\end{array}\right].\]
                An Hermitian matrix is in fact a generalization of a symmetric matrix. The key property of an Hermitian matrix is the same as that of a real symmetric matrix â€“ i.e. the eigenvalues are always
        <strong>
            real
        </strong>
        .
    </span>
    <span class="multilang" lang="no">
        En \(3\times 3\) eksempel på en hermitisk matrise er 
\[ A=\left[\begin{array}{ccc}1&amp;\mathrm{i}&amp;5-2\mathrm{i}\\ -\mathrm{i}&amp;3&amp;0\\ 5+2\mathrm{i}&amp;0&amp;2\end{array}\right].\]
En Hermitisk matrise er faktisk en generalisering av en symmetrisk matrise. Den viktigste egenskapen til en hermitisk matrise er den samme som til en reell symmetrisk matrise - dvs. egenverdiene er alltid
        <strong>
            reelle
        </strong>
        .
    </span>
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9126  -->
    <question type="description">
        <name>
            <text>22.3.2.3 About complex eigenvalues</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        Calculating the eigenvalues of an \(n\times n\) matrix with real elements involves, in principle at least, solving an \(n^{\text{th}}\) order polynomial equation, a quadratic equation if \(n=2\), a cubic equation if \(n=3\), and so on. As is well known, such equations sometimes have only real solutions, but complex solutions (occurring as complex conjugate pairs) can also arise. This situation can therefore arise with the eigenvalues of matrices.
    </span>
    <span class="multilang" lang="no">
        Beregning av egenverdiene til en \(n\times n\) matrise med reelle elementer involverer, i prinsippet i hvert fall, å løse en \(n\)-te gradspolynomligning - en andregradsligning hvis \(n=2\), en tredjegradsligning hvis \(n=3\) og så videre. Som det allrede er kjent, har slike ligninger noen ganger bare reelle løsninger, men komplekse løsninger (som oppstår som komplekse konjugatpar) kan også oppstå. Denne situasjonen kan derfor oppstå med egenverdiene til matriser.
    </span>
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9127  -->
    <question type="description">
        <name>
            <text>22.3.2.5 Real symmetric matrices have real eigenvalues</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        In particular any \(2\times 2\) matrix of the form
                \[ A=\left[\begin{array}{rc}a&amp;b\\ -b&amp;a\end{array}\right]\]
                has complex conjugate eigenvalues \(a\pm \mathrm{i} b\).
    </span>
    <span class="multilang" lang="no">
        Spesielt har enhver \(2 \times 2\) matrise av formen
\[ A=\left[\begin{array}{rc}a&amp;b\\ -b&amp;a\end{array}\right]\]
komplekse konjugerte egenverdier \(a\pm \mathrm{i} b\).
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        A \(3\times 3\) example of a matrix with some complex eigenvalues is
                \[ B=\left[\begin{array}{crr}1&amp;-1&amp;-1\\ 1&amp;-1&amp;0\\ 1&amp;0&amp;-1\end{array}\right].\]
                A straightforward calculation shows that the eigenvalues of \(B\) are
                \[ \lambda=-1 \text{ (real)}, \lambda =\pm \mathrm{i} \text{ (complex conjugates)}.\]
    </span>
    <span class="multilang" lang="no">
        En \(3\times 3\) eksempel av en matrise med noen komplekse egenverdier er
\[B=\left[\begin{array}{crr}1&amp;-1&amp;-1\\ 1&amp;-1&amp;0\\ 1&amp;0&amp;-1\end{array}\right].\]
En enkel beregning viser at egenverdiene til \(B\) er
\[\lambda=-1 \text{ (reell)}, \lambda =\pm \mathrm{i} \text{ (kompleks konjugerte)}.\]
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        With
        <strong>
            symmetric
        </strong>
        matrices on the other hand, complex eigenvalues are not possible.
    </span>
    <span class="multilang" lang="no">
        Med
        <strong>
            symmetriske
        </strong>
        matriser derimot, er komplekse egenverdier ikke mulig.
    </span>
</p>
<div class="HELM_keypoint">
    <h4>
        <span class="multilang" lang="en">
            Key Point
        </span>
        <span class="multilang" lang="no">
            Nøkkelpunkt
        </span>
    </h4>
    <p>
        <span class="multilang" lang="en">
            The eigenvalues of a symmetric matrix with real elements are always real.
        </span>
        <span class="multilang" lang="no">
            Egenverdiene til en symmetrisk matrise med reelle elementer er alltid reelle.
        </span>
    </p>
</div>
<p>
    <span class="multilang" lang="en">
        The general proof of this result in the above Key Point is beyond our scope, but a simple proof for symmetric \(2\times 2\) matrices is straightforward.
    </span>
    <span class="multilang" lang="no">
        Beviset for dette resultatet i den ovennevnte nøkkelpunktet er utenfor vår rekkevidde, men et enkelt bevis for symmetriske \(2\times 2\) matriser er grei.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Let \(A=\left[\begin{array}{cc}a&amp;b\\ b&amp;c\end{array}\right]\) be any \(2\times 2\) symmetric matrix, \(a,\ b,\ c\) being real numbers.
    </span>
    <span class="multilang" lang="no">
        La \(A=\left[\begin{array}{cc}a&amp;b\\ b&amp;c\end{array}\right]\) være en vilkårlig \(2 \times 2\) symmetrisk matrise, der \(a,\ b,\ c\) er reelle tall.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        The characteristic equation for \(A\) is
                \[ (a-\lambda)(c-\lambda)-b^2=0\]
                or, expanding: \[ \lambda^2-(a+c)\lambda+ac-b^2=0 \]
                from which
                \[ \lambda=\dfrac{(a+c)\pm\sqrt{(a+c)^2-4ac+4b^2}}{2}.\]
                The quantity under the square root sign can be treated as follows:
                \[ (a+c)^2-4ac+4b^2=a^2+c^2+2ac-4ac+b^2=(a-c)^2+4b^2\]
                which is always positive and hence \(\lambda\)
        <strong>
            cannot be complex
        </strong>
        .
    </span>
    <span class="multilang" lang="no">
        Den karakteristiske ligningen for \(A\) er 
                \[ (a-\lambda)(c-\lambda)-b^2=0\]
                eller, utvidet: \[ \lambda^2-(a+c)\lambda+ac-b^2=0 \]
                derfra får vi
                \[ \lambda=\dfrac{(a+c)\pm\sqrt{(a+c)^2-4ac+4b^2}}{2}.\]
                Mengden under roten kan behandles som følger:
                \[ (a+c)^2-4ac+4b^2=a^2+c^2+2ac-4ac+b^2=(a-c)^2+4b^2\]
                som alltid vil være positiv, og derfor kan ikke \(\lambda\)
        <strong>
            være komplekse
        </strong>
        .
    </span>
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9128  -->
    <question type="description">
        <name>
            <text>22.3.2.7 Orthogonal vectors</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<div class="HELM_keypoint">
    <h4>
        <span class="multilang" lang="en">
            Key Point
        </span>
        <span class="multilang" lang="no">
            Nøkkelpunkt
        </span>
    </h4>
    <p>
        <span class="multilang" lang="en">
            Two \(n\times 1\) column vectors \(X\) and \(Y\) are
            <strong>
                orthogonal
            </strong>
            if \(X^TY=\mathbf{0}\) or (equivalently) \(Y^TX=\mathbf{0}\).
        </span>
        <span class="multilang" lang="no">
            To \(n\times 1\) kolonnevektorer \(X\) og \(Y\) er
            <strong>
                ortogonale
            </strong>
            hvis \(X^TY=\mathbf{0}\) eller (ekvivalent) \(Y^TX=\mathbf{0}\).
        </span>
    </p>
</div>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9129  -->
    <question type="description">
        <name>
            <text>22.3.2.9 General theory</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<h4>
    <span class="multilang" lang="en">
        General theory
    </span>
    <span class="multilang" lang="no">
        Generell teori
    </span>
</h4>
<p>
    <span class="multilang" lang="en">
        The following proof that eigenvectors corresponding to distinct eigenvalues of a symmetric matrix are orthogonal is straightforward and you are encouraged to follow it through.
    </span>
    <span class="multilang" lang="no">
        Følgende bevis på at egenvektorer som tilhører ulike egenverdier av en symmetrisk matrise er ortogonale er rett frem og du oppfordres til å lese det gjennom.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Let \(A\) be a symmetric \(n\times n\) matrix and let \(\lambda_1,\lambda_2\) be two distinct eigenvalues of \(A\) i.e. \(\lambda_1\neq \lambda_2\) with associated eigenvectors \(X,\ Y\) respectively. We have seen that \(\lambda_1\) and \(\lambda_2\) must be real since \(A\) is symmetric. Then
                \[ AX=\lambda_1X\qquad AY=\lambda_2 Y \tag{1}\]
                Transposing the first of the above equations gives
                \[ X^TA^T=\lambda_1X^T \tag{2}\]
                (Remember that for any two matrices the transpose of a product is the product of the transposes
        <strong>
            in reverse order
        </strong>
        .)
    </span>
    <span class="multilang" lang="no">
        La \(A\) være en symmetrisk \(n\times n\) matrise og la \(\lambda_1,\lambda_2\) være to ulike egenverdier av \(A\) dvs. \(\lambda_1\neq \lambda_2\) med tilhørende egenvektorer \(X,\ Y\) henholdsvis. Vi har sett at \(\lambda_1\) og \(\lambda_2\) må være reelle siden \(A\) er symmetrisk. Da har vi
                                \[ AX=\lambda_1X\qquad AY=\lambda_2 Y \tag{1}\]
                                Transponering av den første av de ovennevnte ligningene gir
                                \[ X^TA^T=\lambda_1X^T \tag{2}\]
                                (Husk at for hvilke som helst to matriser er transponeringen av et produkt lik produktet av transponeringene
        <strong>
            fra høyre til venstre
        </strong>
        )
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        We now multiply both sides of (2) on the right by \(Y\) (as well as putting \(A^T=A\), since \(A\) is symmetric) to give:
                \[ X^TAY=\lambda_1X^TY \tag{3}\]
                But, using the second eigenvalue equation of (1), equation (3) becomes
                \[ X^T\lambda_2Y=\lambda_1X^TY\]
                or, since \(\lambda_2\) is just a number,
                \[ \lambda_2X^TY=\lambda_1 X^TY.\]
                Taking all terms to the same side and factorising gives
                \[ (\lambda_2-\lambda_1)X^TY=\mathbf{0}\]
                from which, since by assumption \(\lambda_1\neq \lambda_2\), we obtain the result
                \[ X^TY=\mathbf{0}\]
                and the orthogonality has been proved.
    </span>
    <span class="multilang" lang="no">
        Vi multipliserer nå begge sider av (2) med \(Y\) (og setter samtidig \(A^T=A\), siden \(A\) er symmetrisk) for å få:
                                \[ X^T\lambda_2Y=\lambda_1X^TY\]
                                eller, siden \(\lambda_2\) bare er et tall,
                                \[ \lambda_2X^TY=\lambda_1 X^TY.\]
                                Flytting av alle ledd til samme side og faktorisering gir
                                \[ (\lambda_2-\lambda_1)X^TY=\mathbf{0}\]
                                fra hvilket vi, siden \(\lambda_1\neq \lambda_2\) får resultatet
                                \[ X^TY=\mathbf{0}\]
                                og ortogonaliteten er bevist.
    </span>
</p>
<div class="HELM_keypoint">
    <h4>
        <span class="multilang" lang="en">
            Key Point
        </span>
        <span class="multilang" lang="no">
            Nøkkelpunkt
        </span>
    </h4>
    <p>
        <span class="multilang" lang="en">
            The eigenvectors associated with distinct eigenvalues of a symmetric matrix are
            <strong>
                mutually orthogonal
            </strong>
            .
        </span>
        <span class="multilang" lang="no">
            Egenvektorene tilhørende ulike egenverdier av en symmetrisk matrise er
            <strong>
                mutuelt ortogonale
            </strong>
            .
        </span>
    </p>
</div>
<p>
    <span class="multilang" lang="en">
        The reader familiar with the algebra of vectors will recall that for two vectors whose Cartesian forms are
                \[\underline{a}=a_x\underline{i}+a_y\underline{j}+a_z\underline{k}\qquad \underline{b}=b_x\underline{i}+b_y\underline{j}+b_z\underline{k}\]
                the scalar (or dot) product is
                \[ \underline{a}\cdot\underline{b}=a_xb_x+a_yb_y+a_zb_z.\]
                Furthermore, if \(\underline{a}\) and \(\underline{b}\) are mutually perpendicular then \(\underline{a}\cdot \underline{b}=0\). (The word ‘orthogonal’ is sometimes used instead of perpendicular in the case.) Our result, that two column vectors are orthogonal if \(X^TY=\mathbf{0}\), may thus be considered as a generalisation of the 3-dimensional result \(\underline{a}\cdot\underline{b}=0\).
    </span>
    <span class="multilang" lang="no">
        Den som er kjent med vektoralgebra vil huske at for to vektorer med kartesiske former er
                                \[\underline{a}=a_x\underline{i}+a_y\underline{j}+a_z\underline{k}\qquad \underline{b}=b_x\underline{i}+b_y\underline{j}+b_z\underline{k}\]
                                skalar (eller prikk) produktet
                                \[ \underline{a}\cdot\underline{b}=a_xb_x+a_yb_y+a_zb_z.\]
                                Videre, hvis \(\underline{a}\) og \(\underline{b}\) er ortogonale så er \(\underline{a}\cdot \underline{b}=0\). (Ortogonalitet brukes noen ganger i stedet for perpendikulær i dette tilfellet.) Vårt resultat, at to kolonnevektorer er ortogonale hvis \(X^TY=\mathbf{0}\), kan derfor betraktes som en generellisering av det 3-dimensjonale resultatet \(\underline{a}\cdot\underline{b}=0\).
    </span>
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text></text>
        </generalfeedback>
        <defaultgrade>0.0000000</defaultgrade>
        <penalty>0.0000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
    </question>
    <!-- question: 9122  -->
    <question type="stack">
        <name>
            <text>22.3.1.2 Non-diagonalisable 3x3 task</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p class="HELM_exercise">
    <span class="multilang" lang="en">
        Exercise
    </span>
    <span class="multilang" lang="no">
        Øving
    </span>
</p>
<p>
    Let \(A = {@a@}\).
</p>
<ol class="HELM_parts">
    <li>
        <span class="multilang" lang="en">
            The eigenvalues of \(A\) (repeated according to multiplicities) are
        </span>
        <span class="multilang" lang="no">
            Egenverdiene til \(A\) (gjentatt i henhold til multiplisitet) er
        </span>
        <div>
            [[input:anseigenvalues]] [[validation:anseigenvalues]]. [[feedback:eigenvalues]]
        </div>
    </li>
    <li>
        <span class="multilang" lang="en">
            Find the eigenvectors of \(A\).
            <br/>
            Enter the eigenvectors as
            <i>
                columns
            </i>
            into the following matrix.
            <br/>
            If there are fewer than three independent eigenvectors then fill the rest of the columns by zeroes:
        </span>
        <span class="multilang" lang="no">
            Finn egenvektorene til \(A\).
            <br/>
            Sett egenvektorene som
            <i>
                kolonner
            </i>
            inn i følgende matrise.
            <br/>
            Hvis det er færre enn tre uavhengige egenvektorer, fyll resten av kolonnene med null :
        </span>
        <div>
            [[input:anseigenvectors]] [[validation:anseigenvectors]] [[feedback:eigenvectors]]
        </div>
    </li>
    <li>
        <span class="multilang" lang="en">
            Can \(A\) be diagonalized?
        </span>
        <span class="multilang" lang="no">
            Kan \(A\) bli diagonalisert?
        </span>
        [[input:ansdiagonalisable]] [[validation:ansdiagonalisable]] [[feedback:diagonalisability]]
    </li>
</ol>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text><![CDATA[
<ol class="HELM_parts">
    <li>
        <p>
            <span class="multilang" lang="en">
                The characteristic equation of \(A\) is \(\det( A-\lambda I ) = {@(lmxchar:"|",a-lambda*ident(3))@} = 0\), i.e. \(0 = {@(lmxchar:saved_lmxchar, p)@} = {@factor(p)@}\) which gives \(\lambda={@eigenvalues[1][1]@}\), \(\lambda={@eigenvalues[1][2]@}\),
                                                \(\lambda={@eigenvalues[1][3]@}\).
            </span>
            <span class="multilang" lang="no">
                Den arakteristiske likningen til \(A\) er \(\det( A-\lambda I ) = {@(lmxchar:"|",a-lambda*ident(3))@} = 0\), dvs. \(0 = {@(lmxchar:saved_lmxchar, p)@} = {@factor(p)@}\) som gir \(\lambda={@eigenvalues[1][1]@}\), \(\lambda={@eigenvalues[1][2]@}\),
                                                                \(\lambda={@eigenvalues[1][3]@}\).
            </span>
        </p>
    </li>
    <li>
        <p>
            <span class="multilang" lang="en">
                For \(\lambda={@eigenvalues[1][1]@}\) the associated eigenvectors satisfy \[{@a@}{@pcovect([x,y,z])@} = {@pcovect(eigenvalues[1][1]*[x,y,z])@}.\] The general solution is \(x={@eigenvectors[1,1]*alpha@}\), \(y={@eigenvectors[2,1]*alpha@}\) and \(z={@eigenvectors[3,1]*alpha@}\),
                                                where \(\alpha\) is arbitrary. Thus an eigenvector is \(X={@alpha*col(eigenvectors,1)@}\), where \(\alpha\) is arbitrary, \(\alpha\neq0\).
            </span>
            <span class="multilang" lang="no">
                For \(\lambda={@eigenvalues[1][1]@}\) er de tilhørende egenvektorene av formen \[{@a@}{@pcovect([x,y,z])@} = {@pcovect(eigenvalues[1][1]*[x,y,z])@}.\] Den generelle løsningen er \(x={@eigenvectors[1,1]*alpha@}\), \(y={@eigenvectors[2,1]*alpha@}\) og \(z={@eigenvectors[3,1]*alpha@}\),
                                                hvor \(\alpha\) er vilkårlig. Dermed er en egenvektor av formen \(X={@alpha*col(eigenvectors,1)@}\), hvor \(\alpha\) er vilkårlig, \(\alpha\neq0\).
            </span>
        </p>
        <p>
            <span class="multilang" lang="en">
                For the repeated eigenvalue \(\lambda={@eigenvalues[1][3]@}\) we must solve \(AY = {@eigenvalues[1][3]@}Y\) for the eigenvector \(Y\): \[{@a@}{@pcovect([x,y,z])@} = {@pcovect(eigenvalues[1][3]*[x,y,z])@}.\] The general solution of this system is
                                                \(x={@eigenvectors[1,2]*beta@}\), \(y={@eigenvectors[2,2]*beta@}\) and \(z={@eigenvectors[3,2]*beta@}\), where \(\beta\) is arbitrary, so the eigenvectors are of the form \(Y=\beta{@col(eigenvectors,2)@}\), where \(\beta\neq0\) is arbitrary.
            </span>
            <span class="multilang" lang="no">
                For den gjentatte egenverdien \(\lambda={@eigenvalues[1][3]@}\) må vi løse \(AY = {@eigenvalues[1][3]@}Y\) for egenvektoren \(Y\): \[{@a@}{@pcovect([x,y,z])@} = {@pcovect(eigenvalues[1][3]*[x,y,z])@}.\] Den generelle løsningen av dette systemet er
                                                \(x={@eigenvectors[1,2]*beta@}\), \(y={@eigenvectors[2,2]*beta@}\) og \(z={@eigenvectors[3,2]*beta@}\), hvor \(\beta\) er vilkårlig, så egenvektorene er av formen \(Y=\beta{@col(eigenvectors,2)@}\), hvor \(\beta\neq0\) er vilkårlig.
            </span>
        </p>
        <p>
            <span class="multilang" lang="en">
                \(X\) and \(Y\) are certainly linearly independent (as we would expect since they correspond to distinct eigenvalues). However, there is only one independent eigenvector of the form \(Y\) corresponding to the repeated eigenvalue \({@eigenvalues[1][3]@}\).
            </span>
            <span class="multilang" lang="no">
                \(X\) og \(Y\) er absolutt lineært uavhengige (som vi forventer siden de tilsvarer distinkte egenverdier). Imidlertid er det bare én uavhengig egenvektor av formen \(Y\) som tilsvarer den gjentatte egenverdien.
            </span>
        </p>
    </li>
    <li>
        <p>
            <span class="multilang" lang="en">
                The conclusion is that since \(A\) is \(3\times 3\) and we can only obtain
                <b>
                    two
                </b>
                linearly independent eigenvectors, \(A\)
                <b>
                    cannot be diagonalized
                </b>
                .
            </span>
            <span class="multilang" lang="no">
                Konklusjonen er at siden \(A\) er \(3\times 3\) og vi kun kan få
                <b>
                    to
                </b>
                lineært uavhengige egenvektorer, så
                <b>
                    kan ikke \(A\)
                </b>
                diagonaliseres.
            </span>
        </p>
    </li>
</ol>
]]></text>
        </generalfeedback>
        <defaultgrade>3.0000000</defaultgrade>
        <penalty>0.1000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
        <stackversion>
            <text>2023010400</text>
        </stackversion>
        <questionvariables>
            <text><![CDATA[/* random SL(3,Z) matrix using LU decomposition */
lucoeffs:[-2,-1,0,1,2]; /* numbers allowed for L U */
l:ident(3); 
l[2,1]:rand(lucoeffs); 
l[3,1]:rand(lucoeffs); 
l[3,2]:rand(lucoeffs);
u:ident(3); 
u[1,2]:rand(lucoeffs); 
u[1,3]:rand(lucoeffs); 
u[2,3]:rand(lucoeffs);
slmat: l . u;
/* The (generalised) eigenvectors are the columns of this matrix */

/* How large do we allow the eigenvalues to be */
control:3;
/* Jordan normal form matrix, 2 eigenvalues, one repeated */
diagmat:zeromatrix(3,3);
diagmat[1,1]:rand_with_prohib(-control,control,[0]);
diagmat[2,2]:rand_with_prohib(-control,control,[0,diagmat[1,1]]);
diagmat[3,3]:diagmat[2,2];
/* non-diagonalisable */
diagmat[2,3]:1;

/* the main matrix */
a: slmat . diagmat . invert(slmat);

/* characteristic polynomial */
p: simplify(charpoly(a,lambda));
p_factored: factor(p);

/* eigenvalues */
eigenvalues : matrix([ diagmat[1,1], diagmat[2,2], diagmat[3,3] ]);



/* eigenvectors model answer */
eigenvectors : copy(slmat);
eigenvectors[1,3]:0; eigenvectors[2,3]:0; eigenvectors[3,3]:0;

/* diagonalisability MCQ */
diagonalisable_ta: [["Yes", false], ["No", true]];

/* save original lmxchar (matrix bracket type) for temporary changes */
saved_lmxchar:lmxchar;

pcovect(l) := transpose(matrix(l));]]></text>
        </questionvariables>
        <specificfeedback format="html">
            <text></text>
        </specificfeedback>
        <questionnote>
            <text>\(A = {@a@}, \qquad \lambda={@eigenvalues[1][1]@}\), \(\lambda={@eigenvalues[1][2]@}\), \(\lambda={@eigenvalues[1][3]@}, \qquad \text{eigenvectors} \; = {@eigenvectors@}   \)</text>
        </questionnote>
        <questionsimplify>1</questionsimplify>
        <assumepositive>0</assumepositive>
        <assumereal>0</assumereal>
        <prtcorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:green;">
    <i class="fa fa-check">
    </i>
</span>
Correct answer, well done.
]]></text>
        </prtcorrect>
        <prtpartiallycorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:orange;">
    <i class="fa fa-adjust">
    </i>
</span>
Your answer is partially correct.
]]></text>
        </prtpartiallycorrect>
        <prtincorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:red;">
    <i class="fa fa-times">
    </i>
</span>
Incorrect answer.
]]></text>
        </prtincorrect>
        <multiplicationsign>none</multiplicationsign>
        <sqrtsign>1</sqrtsign>
        <complexno>i</complexno>
        <inversetrig>cos-1</inversetrig>
        <logicsymbol>lang</logicsymbol>
        <matrixparens>[</matrixparens>
        <variantsselectionseed></variantsselectionseed>
        <input>
            <name>ansdiagonalisable</name>
            <type>dropdown</type>
            <tans>diagonalisable_ta</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>0</mustverify>
            <showvalidation>0</showvalidation>
            <options></options>
        </input>
        <input>
            <name>anseigenvalues</name>
            <type>matrix</type>
            <tans>eigenvalues</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <input>
            <name>anseigenvectors</name>
            <type>matrix</type>
            <tans>eigenvectors</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <prt>
            <name>diagonalisability</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text></text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>String</answertest>
                <sans>ansdiagonalisable</sans>
                <tans><![CDATA["No"]]></tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>diagonalisability-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>diagonalisability-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<span class="multilang" lang="en">
    The matrix \(A\) can
    <b>
        not
    </b>
    be diagonalised.
</span>
<span class="multilang" lang="no">
    Matrisen \(A\) kan
    <b>
        ikke
    </b>
    diagonaliseres.
</span>
<br/>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <prt>
            <name>eigenvalues</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text>/* how many times was the first eigenvalue listed in the student's answer? */
first_multiplicity : lsum(if i=eigenvalues[1][1] then 1 else 0, i, anseigenvalues[1]);
/* the same for the second eigenvalue */
second_multiplicity : lsum(if i=eigenvalues[1][3] then 1 else 0, i, anseigenvalues[1]);</text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>first_multiplicity</sans>
                <tans>0</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>=</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>2</truenextnode>
                <trueanswernote>eigenvalues-1-T</trueanswernote>
                <truefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You didn't find \({@eigenvalues[1][1]@}\) as an eigenvalue of \(A\).
    </span>
    <span class="multilang" lang="no">
        Du fant ikke \({@eigenvalues[1][1]@}\) som en egenverdi av \(A\).
    </span>
</p>
]]></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.4000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>1</falsenextnode>
                <falseanswernote>eigenvalues-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
            <node>
                <name>1</name>
                <answertest>CasEqual</answertest>
                <sans>first_multiplicity</sans>
                <tans>1</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.1000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>2</truenextnode>
                <trueanswernote>eigenvalues-2-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>2</falsenextnode>
                <falseanswernote>eigenvalues-2-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    ✘
    <span class="multilang" lang="en">
        The multiplicity of the eigenvalue \({@eigenvalues[1][1]@}\) is \(1\) and not \({@first_multiplicity@}\).
    </span>
    <span class="multilang" lang="no">
        Multiplisiteten av egenverdien \({@eigenvalues[1][1]@}\) er \(1\) og ikke \({@first_multiplicity@}\).
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>2</name>
                <answertest>AlgEquiv</answertest>
                <sans>second_multiplicity</sans>
                <tans>0</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>eigenvalues-3-T</trueanswernote>
                <truefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You didn't find \({@eigenvalues[1][3]@}\) as an eigenvalue of \(A\).
    </span>
    <span class="multilang" lang="no">
        Du fant ikke \({@eigenvalues[1][3]@}\) som en egenverdi av \(A\).
    </span>
</p>
]]></text>
                </truefeedback>
                <falsescoremode>+</falsescoremode>
                <falsescore>0.4000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>3</falsenextnode>
                <falseanswernote>eigenvalues-3-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
            <node>
                <name>3</name>
                <answertest>AlgEquiv</answertest>
                <sans>second_multiplicity</sans>
                <tans>2</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.1000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>eigenvalues-4-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>eigenvalues-4-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    ✘
    <span class="multilang" lang="en">
        The multiplicity of the eigenvalue \({@eigenvalues[1][3]@}\) is \(2\) and not \({@second_multiplicity@}\).
    </span>
    <span class="multilang" lang="no">
        Multiplisiteten av egenverdien \({@eigenvalues[1][3]@}\) er \(2\) og ikke \({@second_multiplicity@}\).
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <prt>
            <name>eigenvectors</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text><![CDATA[/* extract non-zero columns from the student's answer */
zz : zeromatrix(3,1);
ans_vects : delete(zz, [ col(anseigenvectors,1), col(anseigenvectors,2), col(anseigenvectors,3) ] );

/* which ones are eigenvectors for which eigenvalue? */
first_eigvects : sublist(ans_vects, lambda([v], is(zz=((a-eigenvalues[1][1]*ident(3)) . v))));
second_eigvects : sublist(ans_vects, lambda([v], is(zz=((a-eigenvalues[1][3]*ident(3)) . v))));
not_eigvects : sublist(ans_vects, lambda([v],not(is(member(v,first_eigvects) or member(v,second_eigvects)))));

/* are they linearly independent (if we have at least some non-zero vectors)? */
are_indep : is(length(ans_vects) > 0) and is(rank(anseigenvectors) = length(ans_vects));]]></text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>not_eigvects</sans>
                <tans>[]</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.1000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>1</truenextnode>
                <trueanswernote>eigenvectors-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>+</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>1</falsenextnode>
                <falseanswernote>eigenvectors-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        These non-zero vectors from your answer are not eigenvectors: \({@not_eigvects@}\).
    </span>
    <span class="multilang" lang="no">
        Disse ikke-null vektorene fra svaret ditt er ikke egenvektorer: \({@not_eigvects@}\).
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>1</name>
                <answertest>CasEqual</answertest>
                <sans>first_eigvects</sans>
                <tans>[]</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>2</truenextnode>
                <trueanswernote>eigenvectors-2-T</trueanswernote>
                <truefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You are missing eigenvector(s) for the eigenvalue \({@eigenvalues[1][1]@}\).
    </span>
    <span class="multilang" lang="no">
        Du mangler egenvektor(er) for egenverdien \({@eigenvalues[1][1]@}\).
    </span>
</p>
]]></text>
                </truefeedback>
                <falsescoremode>+</falsescoremode>
                <falsescore>0.4000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>2</falsenextnode>
                <falseanswernote>eigenvectors-2-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
            <node>
                <name>2</name>
                <answertest>AlgEquiv</answertest>
                <sans>second_eigvects</sans>
                <tans>[]</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>3</truenextnode>
                <trueanswernote>eigenvectors-3-T</trueanswernote>
                <truefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You are missing eigenvector(s) for the eigenvalue \({@eigenvalues[1][3]@}\).
    </span>
    <span class="multilang" lang="no">
        Du mangler egenvektor(er) for egenverdien \({@eigenvalues[1][3]@}\).
    </span>
</p>
]]></text>
                </truefeedback>
                <falsescoremode>+</falsescoremode>
                <falsescore>0.4000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>3</falsenextnode>
                <falseanswernote>eigenvectors-3-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
            <node>
                <name>3</name>
                <answertest>AlgEquiv</answertest>
                <sans>are_indep</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.1000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>eigenvectors-4-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>+</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>eigenvectors-4-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The non-zero vectors from your answer are not linearly independent.
    </span>
    <span class="multilang" lang="no">
        Ikke-null vektorene fra svaret ditt er ikke lineært uavhengige.
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>4</name>
                <answertest>CasEqual</answertest>
                <sans>ans_vects</sans>
                <tans>[]</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>eigenvectors-5-T</trueanswernote>
                <truefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        No non-zero vectors were supplied.
    </span>
    <span class="multilang" lang="no">
        Ingen ikke-null vektorer ble levert.
    </span>
</p>
]]></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>0</falsenextnode>
                <falseanswernote>eigenvectors-5-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
        </prt>
        <deployedseed>1264376391</deployedseed>
        <deployedseed>1998088285</deployedseed>
        <deployedseed>1805372345</deployedseed>
        <deployedseed>1980813774</deployedseed>
        <deployedseed>96136408</deployedseed>
        <deployedseed>613577876</deployedseed>
        <deployedseed>1108015710</deployedseed>
        <deployedseed>952127798</deployedseed>
        <deployedseed>739897234</deployedseed>
        <deployedseed>2047475822</deployedseed>
        <deployedseed>613645545</deployedseed>
        <deployedseed>116255339</deployedseed>
        <deployedseed>1406621992</deployedseed>
        <deployedseed>629881932</deployedseed>
        <deployedseed>700778549</deployedseed>
        <deployedseed>309450127</deployedseed>
        <qtest>
            <testcase>1</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["No"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>eigenvalues</value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>eigenvectors</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-T</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvalues</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>eigenvalues-4-T</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>eigenvectors-4-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>2</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["Yes"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>matrix([0,0,0])</value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>matrix([0,0,0],[0,0,0],[0,0,0])</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-F</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvalues</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvalues-3-T</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvectors-5-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>3</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["No"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>matrix([diagmat[1,1],0,0])</value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>addcol(col(eigenvectors,1),zeromatrix(3,1),zeromatrix(3,1))</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-T</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvalues</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvalues-3-T</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>0.6000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvectors-4-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>4</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["Yes"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>matrix([diagmat[3,3],0,0])</value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>addcol(col(slmat,1),col(slmat,1),col(slmat,2))</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-F</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvalues</name>
                <expectedscore>0.4000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvalues-4-F</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>0.9000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvectors-4-F</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>5</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["No"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>matrix([diagmat[1,1],diagmat[1,1],0])</value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>ev(addcol(col(slmat,1)+col(slmat,2),col(slmat,2),col(slmat,3)),simp)</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-T</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvalues</name>
                <expectedscore>0.4000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvalues-3-T</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvectors-4-T</expectedanswernote>
            </expected>
        </qtest>
    </question>
    <!-- question: 9133  -->
    <question type="stack">
        <name>
            <text>22.3.1.3 Diagonalisable 3x3 task</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p class="HELM_exercise">
    <span class="multilang" lang="en">
        Exercise
    </span>
    <span class="multilang" lang="no">
        Øving
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        The matrix \(A = {@a@}\) has eigenvalues \({@eigenvalues[1][1]@},{@eigenvalues[1][2]@},{@eigenvalues[1][3]@}\). The eigenvector corresponding to the eigenvalue \({@eigenvalues[1][1]@}\) is \(X={@col(slmat,1)@}\) or any multiple.
    </span>
    <span class="multilang" lang="no">
        Matrisen \(A = {@a@}\) har egenverdier \({@eigenvalues[1][1]@},{@eigenvalues[1][2]@},{@eigenvalues[1][3]@}\). Egenvektoren som tilhører egenverdien \({@eigenvalues[1][1]@}\) er \(X={@col(slmat,1)@}\) eller en multiplum av denne.
    </span>
    <br/>
</p>
<p>
</p>
<ol class="HELM_parts">
    <li>
        <span class="multilang" lang="en">
            Investigate the eigenvectors associated to the repeated eigenvalue \({@eigenvalues[1][3]@}\).
            <br/>
            Enter linearly independent eigenvectors as
            <i>
                columns
            </i>
            into the following matrix.
            <br/>
            If there are less than two linearly independent eigenvectors, fill the rest of the columns by zeroes:
        </span>
        <span class="multilang" lang="no">
            Undersøk egenvektorene som tilhører den gjentatte egenverdien \({@eigenvalues[1][3]@}\).
            <br/>
            Skriv inn lineært uavhengige egenvektorer som
            <i>
                kolonner
            </i>
            i følgende matrise.
            <br/>
            Hvis det er færre enn to lineært uavhengige egenvektorer, fyll resten av kolonnene med nuller:
        </span>
        <div>
            [[input:anseigenvectors]] [[validation:anseigenvectors]]. [[feedback:eigenvectors]]
        </div>
    </li>
    <li>
        <span class="multilang" lang="en">
            Can \(A\) be diagonalized?
        </span>
        <span class="multilang" lang="no">
            Kan \(A\) diagonaliseres?
        </span>
        [[input:ansdiagonalisable]] [[validation:ansdiagonalisable]] [[feedback:diagonalisability]]
    </li>
</ol>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text><![CDATA[
<ol class="HELM_parts">
    <li>
        <p>
            <span class="multilang" lang="en">
                We must solve \(AY = {@eigenvalues[1][3]@}Y\) for the required eigenvector, i.e. \[{@a@}{@pcovect(vars)@} = {@pcovect(eigenvalues[1][3]*vars)@}.\] Each equation simplifies to \({@eve_equ@}\). We have just one equation in three unknowns, so we can
                                                choose
                <strong>
                    two
                </strong>
                values arbitrarily. For example (choosing some variables to be zero) we find solutions \({@vars[1]@}={@evs[1][1]@}\), \({@vars[2]@}={@evs[1][2]@}\) and \({@vars[3]@}={@evs[1][3]@}\); and \({@vars[1]@}={@evs[2][1]@}\),
                                                \({@vars[2]@}={@evs[2][2]@}\) and \({@vars[3]@}={@evs[2][3]@}\). These give rise to linearly independent eigenvectors \[ Y_1 = {@col(eigenvectors,1)@}, \quad Y_2 = {@col(eigenvectors,2)@}.\]
            </span>
            <span class="multilang" lang="no">
                Vi må løse \(AY = {@eigenvalues[1][3]@}Y\) for den ønskede egenvektoren, dvs. \[{@a@}{@pcovect(vars)@} = {@pcovect(eigenvalues[1][3]*vars)@}.\] Hver likning forenkles til \({@eve_equ@}\). Vi har bare én likning med tre ukjente, så vi kan
                                                                velge
                <strong>
                    to
                </strong>
                verdier vilkårlig. For eksempel (ved å velge noen variabler til å være null) finner vi løsninger \({@vars[1]@}={@evs[1][1]@}\), \({@vars[2]@}={@evs[1][2]@}\) og \({@vars[3]@}={@evs[1][3]@}\); og \({@vars[1]@}={@evs[2][1]@}\),
                                                                \({@vars[2]@}={@evs[2][2]@}\) og \({@vars[3]@}={@evs[2][3]@}\). Disse gir opphav til lineært uavhengige egenvektorer \[ Y_1 = {@col(eigenvectors,1)@}, \quad Y_2 = {@col(eigenvectors,2)@}.\]
            </span>
        </p>
    </li>
    <li>
        <p>
            <span class="multilang" lang="en">
                We can thus form a non-singular modal matrix \(P\) from \(Y_1\) and \(Y_2\) together with \(X\) (given): \[P = {@modal@}.\] We can then indeed diagonalize \(A\) through the transformation \[P^{-1}AP = D = {@diagmat@}.\]
            </span>
            <span class="multilang" lang="no">
                Vi kan dermed danne en ikke-singular modalmatrise \(P\) fra \(Y_1\) og \(Y_2\) sammen med \(X\) (gitt): \[P = {@modal@}.\] Vi kan dermed diagonalisere \(A\) gjennom transformasjonen \[P^{-1}AP = D = {@diagmat@}.\]
            </span>
        </p>
    </li>
</ol>
]]></text>
        </generalfeedback>
        <defaultgrade>2.0000000</defaultgrade>
        <penalty>0.1000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
        <stackversion>
            <text>2023010400</text>
        </stackversion>
        <questionvariables>
            <text><![CDATA[/* random SL(3,Z) matrix using LU decomposition */
lucoeffs:[-2,-1,0,1,2]; /* numbers allowed for L U */
l:ident(3); l[2,1]:rand(lucoeffs); l[3,1]:rand(lucoeffs); l[3,2]:rand(lucoeffs);
u:ident(3); u[1,2]:rand(lucoeffs); u[1,3]:rand(lucoeffs); u[2,3]:rand(lucoeffs);
slmat: l . u;
/* the (generalised) eigenvectors are the columns of this matrix */

/* how large do we allow the eigenvalues to be */
control:3;
/* Jordan normal form matrix, 2 eigenvalues, one repeated */
diagmat:zeromatrix(3,3);
diagmat[1,1]:rand_with_prohib(-control,control,[0]);
diagmat[2,2]:rand_with_prohib(-control,control,[0,diagmat[1,1]]);
diagmat[3,3]:diagmat[2,2];

/* the main matrix */
a: slmat . diagmat . invert(slmat);

/* eigenvalues */
eigenvalues : matrix([ diagmat[1,1], diagmat[2,2], diagmat[3,3] ]);

/* eigenvectors model answer */
evs_raw : eigenvectors(a); /* use maxima function - it gives "nicer" eigenvectors */
evs : sublist(evs_raw[2], lambda([l],is(length(l)=2)))[1];
/* fix denominators */
for i in [1,2] do evs[i] : evs[i]*lcm(map(denom,evs[i]));
/* now as a matrix */
eigenvectors : transpose(apply(matrix,evs));

/* modal matrix */
modal : addcol(col(slmat,1),col(eigenvectors,1),col(eigenvectors,2));

/* diagonalisability MCQ */
diagonalisable_ta: [["Yes", true], ["No", false]];

/* preparing to print the equation */
coeffs : rref( a - eigenvalues[1][3]*ident(3) )[1];
/* variable names */
vars : [x,y,z];
/* construct the equation (hopefully) without fractions */
eve_equ : num(ratsimp(coeffs . vars)) = 0;

/* typesetting column vectors helper */
pcovect(l) := transpose(matrix(l));]]></text>
        </questionvariables>
        <specificfeedback format="html">
            <text></text>
        </specificfeedback>
        <questionnote>
            <text>\(A = {@a@}, \qquad \text{eigenvalues} \; = {@eigenvectors@}\)</text>
        </questionnote>
        <questionsimplify>1</questionsimplify>
        <assumepositive>0</assumepositive>
        <assumereal>0</assumereal>
        <prtcorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:green;">
    <i class="fa fa-check">
    </i>
</span>
Correct answer, well done.
]]></text>
        </prtcorrect>
        <prtpartiallycorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:orange;">
    <i class="fa fa-adjust">
    </i>
</span>
Your answer is partially correct.
]]></text>
        </prtpartiallycorrect>
        <prtincorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:red;">
    <i class="fa fa-times">
    </i>
</span>
Incorrect answer.
]]></text>
        </prtincorrect>
        <multiplicationsign>none</multiplicationsign>
        <sqrtsign>1</sqrtsign>
        <complexno>i</complexno>
        <inversetrig>cos-1</inversetrig>
        <logicsymbol>lang</logicsymbol>
        <matrixparens>[</matrixparens>
        <variantsselectionseed></variantsselectionseed>
        <input>
            <name>ansdiagonalisable</name>
            <type>dropdown</type>
            <tans>diagonalisable_ta</tans>
            <boxsize>15</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>0</mustverify>
            <showvalidation>0</showvalidation>
            <options></options>
        </input>
        <input>
            <name>anseigenvectors</name>
            <type>matrix</type>
            <tans>eigenvectors</tans>
            <boxsize>15</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <prt>
            <name>diagonalisability</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text></text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>String</answertest>
                <sans>ansdiagonalisable</sans>
                <tans><![CDATA["Yes"]]></tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>diagonalisability-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>diagonalisability-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The matrix \(A\)
        <b>
            can
        </b>
        be diagonalised.
    </span>
    <span class="multilang" lang="no">
        Matrisen \(A\)
        <b>
            kan
        </b>
        diagonaliseres.
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <prt>
            <name>eigenvectors</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text><![CDATA[/* extract non-zero columns from the student's answer */
zz : zeromatrix(3,1);
ans_vects : delete(zz, [ col(anseigenvectors,1), col(anseigenvectors,2) ] );

/* which ones are eigenvectors? */
eigvects : sublist(ans_vects, lambda([v], is(zz=((a-eigenvalues[1][3]*ident(3)) . v))));
not_eigvects : sublist(ans_vects, lambda([v],not(is(zz=((a-eigenvalues[1][3]*ident(3)) . v)))));

/* create a single matrix from the eigenvectors */
eigvects_matx : if eigvects=[] then matrix([0]) else transpose(apply(matrix,map(flatten,map(args,eigvects))));

/* linear independence */
num_indep: rank(eigvects_matx);
are_indep : is(num_indep = length(eigvects) and num_indep > 0);]]></text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>not_eigvects</sans>
                <tans>[]</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>1</truenextnode>
                <trueanswernote>eigenvectors-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>1</falsenextnode>
                <falseanswernote>eigenvectors-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        These non-zero vectors from your answer are not eigenvectors: \({@not_eigvects@}\).
    </span>
    <span class="multilang" lang="no">
        Disse ikke-null vektorene fra svaret ditt er ikke egenvektorer: \({@not_eigvects@}\).
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>1</name>
                <answertest>CasEqual</answertest>
                <sans>are_indep</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>3</truenextnode>
                <trueanswernote>eigenvectors-2-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>+</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>3</falsenextnode>
                <falseanswernote>eigenvectors-2-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        One of your vectors is a multiple of the other, so they are not linearly independent.
    </span>
    <span class="multilang" lang="no">
        En av vektorene dine er et multiplum av det andre, så de er ikke lineært uavhengige.
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>3</name>
                <answertest>CasEqual</answertest>
                <sans>num_indep</sans>
                <tans>2</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>eigenvectors-4-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>+</falsescoremode>
                <falsescore>0.5000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>eigenvectors-4-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You found one (independent) eigenvector for the eigenvalue \({@eigenvalues[1][3]@}\), but it is possible to find two linearly independent ones.
    </span>
    <span class="multilang" lang="no">
        Du fant en (uavhengig) egenvektor for egenverdien \({@eigenvalues[1][3]@}\), men det er mulig å finne to lineært uavhengige egenvektorer.
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>4</name>
                <answertest>CasEqual</answertest>
                <sans>eigvects</sans>
                <tans>[]</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>eigenvectors-5-T</trueanswernote>
                <truefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        None of your vectors are eigenvectors for the eigenvalue \({@eigenvalues[1][3]@}\).
    </span>
    <span class="multilang" lang="no">
        Ingen av vektorene dine er egenvektorer for egenverdien \({@eigenvalues[1][3]@}\).
    </span>
</p>
]]></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>0</falsenextnode>
                <falseanswernote>eigenvectors-5-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
        </prt>
        <deployedseed>312066750</deployedseed>
        <deployedseed>374819815</deployedseed>
        <deployedseed>630460069</deployedseed>
        <deployedseed>2141262565</deployedseed>
        <deployedseed>881549397</deployedseed>
        <deployedseed>733501754</deployedseed>
        <deployedseed>736256485</deployedseed>
        <deployedseed>389996266</deployedseed>
        <deployedseed>475216275</deployedseed>
        <deployedseed>825808298</deployedseed>
        <deployedseed>482317747</deployedseed>
        <deployedseed>1428756604</deployedseed>
        <deployedseed>1559471154</deployedseed>
        <deployedseed>1896952339</deployedseed>
        <deployedseed>1416853937</deployedseed>
        <deployedseed>1393621597</deployedseed>
        <deployedseed>190620701</deployedseed>
        <deployedseed>1885014227</deployedseed>
        <qtest>
            <testcase>1</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["Yes"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>submatrix(slmat,1)</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-T</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>eigenvectors-4-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>2</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["No"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>zeromatrix(3,2)</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-F</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvectors-5-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>3</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["No"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>submatrix(slmat,3)</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-F</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvectors-4-F</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>4</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["Yes"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>addcol(col(slmat,1),zeromatrix(3,1))</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-T</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvectors-5-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>5</testcase>
            <testinput>
                <name>ansdiagonalisable</name>
                <value><![CDATA["No"]]></value>
            </testinput>
            <testinput>
                <name>anseigenvectors</name>
                <value>ev(addcol(col(slmat,3),2*col(slmat,3)), simp)</value>
            </testinput>
            <expected>
                <name>diagonalisability</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>diagonalisability-1-F</expectedanswernote>
            </expected>
            <expected>
                <name>eigenvectors</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>eigenvectors-4-F</expectedanswernote>
            </expected>
        </qtest>
    </question>
    <!-- question: 9138  -->
    <question type="stack">
        <name>
            <text>22.3.2.11 Orthogonal matrices</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p class="HELM_exercise">
    <span class="multilang" lang="en">
        Exercise
    </span>
    <span class="multilang" lang="no">
        Øving
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Determine \({@u@}\) and \({@v@}\) so that the matrices \[A={@a_mat@},\qquad B={@b_mat@}\] are orthogonal. Then verify that \(A^TA=AA^T=I\) and \(B^TB=BB^T=I\) i.e. that \(A^T=A^{-1}\) and \(B^T=B^{-1}\).
    </span>
    <span class="multilang" lang="no">
        Bestem \({@u@}\) og \({@v@}\) slik at matrisene \[A={@a_mat@},\qquad B={@b_mat@}\] er ortogonale. Sjekk så at \(A^TA=AA^T=I\) og \(B^TB=BB^T=I\) dvs. at \(A^T=A^{-1}\) og \(B^T=B^{-1}\).
    </span>
</p>
<p>
    \({@u@}=\) [[input:ans_a]] [[validation:ans_a]]     \({@v@}=\) [[input:ans_b]] [[validation:ans_b]]
</p>
<p>
    [[feedback:prt_a]] [[feedback:prt_b]]
    <br/>
</p>
<p>
    <span class="multilang" lang="en">
        (Note: a square root can be entered with
        <code>
            sqrt()
        </code>
        ; for example \({@sqrt(5)@}\) would be entered as
        <code>
            sqrt(5)
        </code>
        .)
    </span>
    <span class="multilang" lang="no">
        (Merk: en kvadratrot kan skrives med
        <code>
            sqrt()
        </code>
        ; for eksempel skrives \({@sqrt(5)@}\) som
        <code>
            sqrt(5)
        </code>
        .)
    </span>
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text><![CDATA[
<p>
    <strong>
        <span class="multilang" lang="en">
            Matrix \(A\)
        </span>
        <span class="multilang" lang="no">
            Matrise \(A\)
        </span>
    </strong>
</p>
<p>
    <span class="multilang" lang="en">
        <i>
            Approach 1
        </i>
        : For \(A\) to be orthogonal, its columns must be orthogonal to each other. This means \[{@matrix([0])@} = {@transpose(col(a_mat,1))@}{@col(a_mat,2)@} = {@(simp:false,a_dotprod)@} = {@(simp:true,a_dotprod)@}\] from which \({@u@}={@a_mat[1,1]@}\).
    </span>
    <span class="multilang" lang="no">
        <i>
            Metode 1
        </i>
        : For at \(A\) skal være ortogonal, må kolonnene være ortogonale til hverandre. Dette betyr at \[{@matrix([0])@} = {@transpose(col(a_mat,1))@}{@col(a_mat,2)@} = {@(simp:false,a_dotprod)@} = {@(simp:true,a_dotprod)@}\] der \({@u@}={@a_mat[1,1]@}\).
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        <i>
            Approach 2
        </i>
        : From the above description of \(2\times2\) orthogonal matrices, we know they are all of the form \({@matrix([cos(theta),sin(theta)],[-sin(theta),cos(theta)])@}\) for some real number \({@theta@}\). In particular, their diagonal entries
                are the same, hence \({@u@}={@a_mat[1,1]@}\).
    </span>
    <span class="multilang" lang="no">
        <i>
            Metode 2
        </i>
        : Fra beskrivelsen av \(2\times2\) ortogonale matriser ovenfor, vet vi at de alle er av formen \({@matrix([cos(theta),sin(theta)],[-sin(theta),cos(theta)])@}\) for noen reell verdi \({@theta@}\). Spesielt er diagonalelementene like, så \({@u@}={@a_mat[1,1]@}\).
    </span>
</p>
<p>
    <strong>
        <span class="multilang" lang="en">
            Matrix \(B\)
        </span>
        <span class="multilang" lang="no">
            Matrise \(B\)
        </span>
    </strong>
</p>
<p>
    <span class="multilang" lang="en">
        The columns of the matrix \(B\) are orthogonal to each other for any choice of \({@v@}\). However each column of an orthogonal matrix has unit magnitude. For the second column of \(B\), this leads to \[1^2={@b_mat[1,2]@}^2+{@b_mat[2,2]@}^2+{@b_mat[3,2]@}^2
                                = {@b_mat[1,2]^2+b_mat[2,2]^2+b_mat[3,2]^2@}, \] thus \({@v@} =\pm 1\).
    </span>
    <span class="multilang" lang="no">
        Kolonnene til matrise \(B\) er ortogonale til hverandre for hvilken som helst valg av \({@v@}\). Likevel har hver kolonne i en ortogonal matrise enhetslengde. For den andre kolonnen i \(B\) gir dette \[1^2={@b_mat[1,2]@}^2+{@b_mat[2,2]@}^2+{@b_mat[3,2]@}^2
                                = {@b_mat[1,2]^2+b_mat[2,2]^2+b_mat[3,2]^2@}, \] så \({@v@} =\pm 1\).
    </span>
</p>
]]></text>
        </generalfeedback>
        <defaultgrade>1.0000000</defaultgrade>
        <penalty>0.1000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
        <stackversion>
            <text>2023010400</text>
        </stackversion>
        <questionvariables>
            <text><![CDATA[angles:[%pi*[1/6,1/3,2/3,5/6,7/6,4/3,5/3,11/6], %pi*[1/4,3/4,5/4,7/4]];
u:a; v:b;
ind2:rand(2)+1; a_ang: rand(angles[ind2]); b_ang: rand(angles[3-ind2]);
a_mat: matrix([cos(a_ang),sin(a_ang)],[-sin(a_ang),u]);
b_mat: matrix([cos(b_ang),0,sin(b_ang)],[0,v,0],[-sin(b_ang),0,cos(b_ang)]);

/* preparing for printing the solution */
dotprod_comp1_list(v1,v2):=matrix([ lreduce("+",map("*",v1,v2)) ]);
col_list(m,i):=first(args(transpose(col(m,i))));
simp:false;
a_dotprod:dotprod_comp1_list(col_list(a_mat,1),col_list(a_mat,2));
simp:true;
]]></text>
        </questionvariables>
        <specificfeedback format="html">
            <text></text>
        </specificfeedback>
        <questionnote>
            <text>\(A = {@a_mat@}, B = {@b_mat@}, \qquad a = {@cos(a_ang)@}, b = 1 \)</text>
        </questionnote>
        <questionsimplify>1</questionsimplify>
        <assumepositive>0</assumepositive>
        <assumereal>0</assumereal>
        <prtcorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:green;">
    <i class="fa fa-check">
    </i>
</span>
Correct answer, well done.
]]></text>
        </prtcorrect>
        <prtpartiallycorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:orange;">
    <i class="fa fa-adjust">
    </i>
</span>
Your answer is partially correct.
]]></text>
        </prtpartiallycorrect>
        <prtincorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:red;">
    <i class="fa fa-times">
    </i>
</span>
Incorrect answer.
]]></text>
        </prtincorrect>
        <multiplicationsign>dot</multiplicationsign>
        <sqrtsign>1</sqrtsign>
        <complexno>i</complexno>
        <inversetrig>cos-1</inversetrig>
        <logicsymbol>lang</logicsymbol>
        <matrixparens>[</matrixparens>
        <variantsselectionseed></variantsselectionseed>
        <input>
            <name>ans_a</name>
            <type>numerical</type>
            <tans>cos(a_ang)</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>1</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <input>
            <name>ans_b</name>
            <type>numerical</type>
            <tans>1</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>1</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <prt>
            <name>prt_a</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text>simp:false;
a_ans_dotprod:dotprod_comp1_list([a_mat[1,1],a_mat[2,1]],[a_mat[1,2],ans_a]);
simp:true;</text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>AlgEquiv</answertest>
                <sans>ans_a</sans>
                <tans>cos(a_ang)</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_a-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_a-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The columns of \(A\) need to be orthogonal, but with \({@u@} = {@ans_a@}\), we have \[{@transpose(col(a_mat,1))@}{@matrix([a_mat[1,2]],[ans_a])@}={@(simp:false,make_multsgn("cross"),a_ans_dotprod)@} = {@(simp:true,a_ans_dotprod)@} \neq {@matrix([0])@}.\]
    </span>
    <span class="multilang" lang="no">
        Kolonnene til \(A\) må være ortogonale, men med \({@u@} = {@ans_a@}\), har vi \[{@transpose(col(a_mat,1))@}{@matrix([a_mat[1,2]],[ans_a])@}={@(simp:false,make_multsgn("cross"),a_ans_dotprod)@} = {@(simp:true,a_ans_dotprod)@} \neq {@matrix([0])@}.\]
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <prt>
            <name>prt_b</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text>b_ans_check:is(member(ans_b,[1,-1]));</text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>b_ans_check</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_b-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_b-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The columns of \(B\) need to have unit magnitude, but with \({@v@}={@ans_b@}\) the magnitude of the second column is \[\sqrt{{@b_mat[1,2]@}^2+{@ans_b@}^2+{@b_mat[3,2]@}^2} = \sqrt{{@b_mat[1,2]^2+ans_b^2+b_mat[3,2]^2@}} = {@sqrt(b_mat[1,2]^2+ans_b^2+b_mat[3,2]^2)@} \neq 1.\]
    </span>
    <span class="multilang" lang="no">
        Kolonnene til \(B\) må ha enhetslengde, men med \({@v@}={@ans_b@}\) er lengden til den andre kolonnen \[\sqrt{{@b_mat[1,2]@}^2+{@ans_b@}^2+{@b_mat[3,2]@}^2} = \sqrt{{@b_mat[1,2]^2+ans_b^2+b_mat[3,2]^2@}} = {@sqrt(b_mat[1,2]^2+ans_b^2+b_mat[3,2]^2)@} \neq 1.\]
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <deployedseed>1475625346</deployedseed>
        <deployedseed>306760336</deployedseed>
        <deployedseed>317651943</deployedseed>
        <deployedseed>1667450243</deployedseed>
        <deployedseed>702966124</deployedseed>
        <deployedseed>1245053452</deployedseed>
        <deployedseed>1952049461</deployedseed>
        <deployedseed>1030001422</deployedseed>
        <deployedseed>1212360488</deployedseed>
        <deployedseed>1614117515</deployedseed>
        <qtest>
            <testcase>1</testcase>
            <testinput>
                <name>ans_a</name>
                <value>a_mat[1,1]</value>
            </testinput>
            <testinput>
                <name>ans_b</name>
                <value>1</value>
            </testinput>
            <expected>
                <name>prt_a</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_a-1-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_b</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_b-1-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>2</testcase>
            <testinput>
                <name>ans_a</name>
                <value>0</value>
            </testinput>
            <testinput>
                <name>ans_b</name>
                <value>0</value>
            </testinput>
            <expected>
                <name>prt_a</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_a-1-F</expectedanswernote>
            </expected>
            <expected>
                <name>prt_b</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_b-1-F</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>3</testcase>
            <testinput>
                <name>ans_a</name>
                <value>a</value>
            </testinput>
            <testinput>
                <name>ans_b</name>
                <value>-1</value>
            </testinput>
            <expected>
                <name>prt_a</name>
                <expectedscore></expectedscore>
                <expectedpenalty></expectedpenalty>
                <expectedanswernote>NULL</expectedanswernote>
            </expected>
            <expected>
                <name>prt_b</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_b-1-T</expectedanswernote>
            </expected>
        </qtest>
    </question>
    <!-- question: 9139  -->
    <question type="stack">
        <name>
            <text>22.3.2.13 3x3 Symmetric Eigentask</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p class="HELM_exercise">
    Exercise
</p>
<p>
    The symmetric matrix \[A={@a@}\] has eigenvalues \({@double_eigval@},{@double_eigval@},{@single_eigval@}\) (i.e. eigenvalue \({@double_eigval@}\) is repeated with multiplicity \(2\)).
</p>
<p>
    Associated with the non-repeated eigenvalue \({@single_eigval@}\) is an eigenvector \[X={@covect(single_eigvec)@}\] (or any non-zero multiple).
</p>
<ol class="HELM_parts">
    <li>
        <div>
            Normalize the eigenvector \(X\): [[input:ans_xunit]] [[validation:ans_xunit]]
        </div>
        [[feedback:prt_xunit]]
    </li>
    <li>
        <p>
            Investigate the eigenvectors associated with the repeated eigenvalue \({@double_eigval@}\): find a general form of these eigenvectors:
        </p>
        <div>
            [[input:ans_dvecs]] [[validation:ans_dvecs]]
        </div>
        [[feedback:prt_dvecs]]
    </li>
</ol>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text><![CDATA[
<ol class="HELM_parts">
    <li>
        <p>
            Normalizing \(X\) which has magnitude \(\sqrt{({@single_eigvec[1]@})^2+({@single_eigvec[2]@})^2+({@single_eigvec[3]@})^2} = {@norm(single_eigvec)@}\) gives \[\frac{1}{{@norm(single_eigvec)@}}{@covect(single_eigvec)@} = {@single_normalized@}.\]
        </p>
    </li>
    <li>
        <p>
            The eigenvectors associated with \(\lambda={@double_eigval@}\) satisfy \(AY={@double_eigval@}Y\) which gives \[{@a-double_eigval*ident(3)@}{@covect([x,y,z])@} = {@zeromatrix(3,1)@}.\] All three equations simplify to \({@eq@}\). Having a single
                                                equation with three unknowns, we choose two of the variables to be parameters \({@uu@},{@vv@}\) and thus obtain that \[Y={@covect(gensol)@}\] where \({@uu@},{@vv@}\) are arbitrary (but not both simultaneously zero).
        </p>
    </li>
</ol>
<p>
    <strong>
        Further discussion
    </strong>
</p>
<p>
    A certain amount of care is now require in the choice of \({@uu@}\) and \({@vv@}\) if we are to find an orthogonal modal matrix to diagonalize \(A\).
</p>
<p>
    For any choice \[X^TY = {@matrix(single_eigvec)@}{@covect(gensol)@} = {@(simp:false,xy_comp)@} = {@(simp:true,zeromatrix(1,1))@},\] so \(X\) and \(Y\) are orthogonal. (The normalization of \(X\) does not affect this.)
</p>
<p>
    However, we also need two
    <strong>
        orthogonal
    </strong>
    eigenvectors of the form \({@covect(gensol)@}\). One possibility to calculate them is as follows. Obtain one vector by choosing both parameters, for example \({@uu@}=0\), \({@vv@}=1\) which yields
                \(Y^{(1)}={@covect(vecs[2])@}\). To calculate the second vector, we consider the equation expressing orthogonality, that is, \(Y^TY^{(1)}={@zeromatrix(1,1)@}\), which simplifies to \({@yy1_comp@}=0\). Choosing \({@uu@}=1\), we calculate \({@vv@}\),
                which leads to the vector \(Y^{(2)}={@covect(vecs[1])@}\).
</p>
<p>
    After normalization, these become \(Y^{(1)}={@covect(vecs_norm[2])@}\) and \(Y^{(2)}={@covect(vecs_norm[1])@}\). Hence the matrix \[P = \left[\begin{matrix}X&amp;\vdots&amp;Y^{(1)}&amp;\vdots &amp;Y^{(2)}\end{matrix}\right] = {@modalmat@}\] is orthogonal
                and diagonalizes \(A\): \[P^TAP = {@diag_matrix(single_eigval,double_eigval,double_eigval)@}.\]
</p>
]]></text>
        </generalfeedback>
        <defaultgrade>2.0000000</defaultgrade>
        <penalty>0.1000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
        <stackversion>
            <text>2020120600</text>
        </stackversion>
        <questionvariables>
            <text><![CDATA[/* use_mats: a static list of 3x3 symmetric ±2,±√(2)±1,0-valued matxs, 2+1 integer eigenvalues, not block-diag */
/* generated in maxima; code from https://github.com/spakula/maxima-stack/blob/master/generators.mac */
use_mats:[matrix([-2,-2,-2],[-2,1,-1],[-2,-1,1]),matrix([-2,-2,-1],[-2,1,2],[-1,2,-2]),matrix([-2,-2,1],[-2,1,-2],[1,-2,-2]),matrix([-2,-2,2],[-2,-2,2],[2,2,-2]),matrix([-2,-2,2],[-2,1,1],[2,1,1]),matrix([-2,-2,-sqrt(2)],[-2,-2,-sqrt(2)],[-sqrt(2),-sqrt(2),-1]),matrix([-2,-2,sqrt(2)],[-2,-2,sqrt(2)],[sqrt(2),sqrt(2),-1]),matrix([-2,-1,-1],[-1,-2,-1],[-1,-1,-2]),matrix([-2,-1,1],[-1,-2,1],[1,1,-2]),matrix([-2,-1,-sqrt(2)],[-1,-2,sqrt(2)],[-sqrt(2),sqrt(2),-1]),matrix([-2,1,2],[1,-2,2],[2,2,1]),matrix([-2,1,-sqrt(2)],[1,-2,-sqrt(2)],[-sqrt(2),-sqrt(2),-1]),matrix([-2,1,sqrt(2)],[1,-2,sqrt(2)],[sqrt(2),sqrt(2),-1]),matrix([-2,2,2],[2,1,-1],[2,-1,1]),matrix([-2,2,-sqrt(2)],[2,-2,sqrt(2)],[-sqrt(2),sqrt(2),-1]),matrix([-2,-sqrt(2),-sqrt(2)],[-sqrt(2),-1,-1],[-sqrt(2),-1,-1]),matrix([-2,-sqrt(2),-sqrt(2)],[-sqrt(2),-1,2],[-sqrt(2),2,-1]),matrix([-2,-sqrt(2),sqrt(2)],[-sqrt(2),-1,-2],[sqrt(2),-2,-1]),matrix([-2,-sqrt(2),sqrt(2)],[-sqrt(2),-1,1],[sqrt(2),1,-1]),matrix([-2,sqrt(2),sqrt(2)],[sqrt(2),-1,-1],[sqrt(2),-1,-1]),matrix([-2,sqrt(2),sqrt(2)],[sqrt(2),-1,2],[sqrt(2),2,-1]),matrix([-1,-2,2],[-2,-1,2],[2,2,-1]),matrix([-1,-2,-sqrt(2)],[-2,-1,-sqrt(2)],[-sqrt(2),-sqrt(2),0]),matrix([-1,-2,sqrt(2)],[-2,-1,sqrt(2)],[sqrt(2),sqrt(2),0]),matrix([-1,-1,1],[-1,-1,1],[1,1,-1]),matrix([-1,-1,-sqrt(2)],[-1,-1,sqrt(2)],[-sqrt(2),sqrt(2),0]),matrix([-1,1,-sqrt(2)],[1,-1,-sqrt(2)],[-sqrt(2),-sqrt(2),0]),matrix([-1,1,sqrt(2)],[1,-1,sqrt(2)],[sqrt(2),sqrt(2),0]),matrix([-1,2,-sqrt(2)],[2,-1,sqrt(2)],[-sqrt(2),sqrt(2),0]),matrix([-1,-sqrt(2),-sqrt(2)],[-sqrt(2),0,-1],[-sqrt(2),-1,0]),matrix([-1,-sqrt(2),-sqrt(2)],[-sqrt(2),0,2],[-sqrt(2),2,0]),matrix([-1,-sqrt(2),sqrt(2)],[-sqrt(2),0,-2],[sqrt(2),-2,0]),matrix([-1,-sqrt(2),sqrt(2)],[-sqrt(2),0,1],[sqrt(2),1,0]),matrix([-1,sqrt(2),sqrt(2)],[sqrt(2),0,-1],[sqrt(2),-1,0]),matrix([-1,sqrt(2),sqrt(2)],[sqrt(2),0,2],[sqrt(2),2,0])];
/* a:rand([-1,1])*rand(use_mats)+rand([-2,-1,0,1,2])*ident(3); */ /* this sometimes gives matrix for which eigenvectors(a) silently gives a wrong result */
/* so instead just do this for the matrices that are tested to not fail, and _then_ adjust */
a:rand(use_mats);
ee:eigenvectors(a);
shift:rand([-2,-1,0,1,2]);
a:a+shift*ident(3);
ee[1][1]:ee[1][1]+shift;

clear_denoms_list_getdenom(l):=block([varr],denom(ratsimp(l.makelist(varr[i],i,1,length(l)))));
clear_denoms_list(l):=clear_denoms_list_getdenom(l)*l;
covect(l):=transpose(matrix(l));
norm(l):=sqrt(lreduce("+",makelist(x^2,x,l)));

double_eig_i:sublist_indices(ee[1][2],lambda([t],t=2))[1];
double_eigval:ee[1][1][double_eig_i];
single_eigval:ee[1][1][3-double_eig_i];
single_eigvec:clear_denoms_list(ee[2][3-double_eig_i][1]);
single_normalized:covect(single_eigvec/(norm(single_eigvec)));

/* preparing for printing */
uu:alpha; vv:beta;
reduce_gcd_list(v):=block([d],d:lreduce('gcd,v),v/d);
eq:reduce_gcd_list(args(a-double_eigval*ident(3))[1]) . [x,y,z] = 0;
/* want two orthogonal solutions of an equation (1 homog lin eq in x,y,z) */
gensol_r:linsolve(eq,[x,y,z]);
gensol:subst(subst([%rnum_list[1]=uu,%rnum_list[2]=vv],gensol_r), [x,y,z]);
getvecs1(sol):=block([eqn,ret:[]],push(subst([uu=0,vv=1],sol),ret),eqn:subst(uu=1,ret[1] . sol = 0),push( subst(append(linsolve(eqn,vv),[uu=1]), sol), ret),ret);
vecs:getvecs1(gensol);
yy1_comp:simplify(gensol . vecs[2]);
yy1_comp:denom(ratsimp(yy1_comp))*yy1_comp;
vecs_norm:map(lambda([t],t/norm(t)),vecs);
modalmat:addcol(single_normalized,covect(vecs_norm[2]),covect(vecs_norm[1]));

dotprod_comp2_list(v1,v2):=matrix([ lreduce("+",ev(map("*",v1,v2),simp,ratsimp)) ]);
simp:false;
xy_comp:dotprod_comp2_list(single_eigvec,gensol);
simp:true;]]></text>
        </questionvariables>
        <specificfeedback format="html">
            <text></text>
        </specificfeedback>
        <questionnote>
            <text>\(A = {@a@}, \qquad \text{eigenvalues} \; {@double_eigval@},{@double_eigval@},{@single_eigval@}, \qquad X = {@single_eigval@} \implies X = {@single_normalized@}, \qquad {@covect(gensol)@}  \)</text>
        </questionnote>
        <questionsimplify>1</questionsimplify>
        <assumepositive>0</assumepositive>
        <assumereal>0</assumereal>
        <prtcorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:green;">
    <i class="fa fa-check">
    </i>
</span>
Correct answer, well done.
]]></text>
        </prtcorrect>
        <prtpartiallycorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:orange;">
    <i class="fa fa-adjust">
    </i>
</span>
Your answer is partially correct.
]]></text>
        </prtpartiallycorrect>
        <prtincorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:red;">
    <i class="fa fa-times">
    </i>
</span>
Incorrect answer.
]]></text>
        </prtincorrect>
        <multiplicationsign>dot</multiplicationsign>
        <sqrtsign>1</sqrtsign>
        <complexno>i</complexno>
        <inversetrig>cos-1</inversetrig>
        <logicsymbol>lang</logicsymbol>
        <matrixparens>[</matrixparens>
        <variantsselectionseed></variantsselectionseed>
        <input>
            <name>ans_dvecs</name>
            <type>matrix</type>
            <tans>covect(gensol)</tans>
            <boxsize>20</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <input>
            <name>ans_xunit</name>
            <type>matrix</type>
            <tans>single_normalized</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <prt>
            <name>prt_dvecs</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text><![CDATA[sa1:expand(ans_dvecs);
lvars:listofvars(sa1);
/* check if the expression in linear in variables */
deg:apply(max, maplist(lambda([ex], hipow(sa1, ex)), lvars));
deg:max(deg,hipow(subst(map(lambda([var],var=ppppp),lvars),sa1),ppppp));
sa_is_linear:is(deg<=1);

/* is a vector in the described set? (expr: column vector, list:list)*/
is_vect_in_space(expr,list):=is(length(ev(linsolve(flatten(args(expr))-list,listofvars(expr))))>0);
sa_contains_eigspace:is_vect_in_space(sa1,[0,0,0]) and is_vect_in_space(sa1,vecs[1]) and is_vect_in_space(sa1,vecs[2]);
sa_dim:rank(coefmatrix(flatten(args(sa1)),lvars));]]></text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>sa_is_linear</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>1</truenextnode>
                <trueanswernote>prt_dvecs-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_dvecs-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    The general form of eigenvectors is always a
    <em>
        linear
    </em>
    expression, i.e. each coordinate is a sum of terms, each of which is a number multiplied by a parameter. There are no powers of parameters, or multiplication between the parameters themselves.
</p>
<p>
    The expression(s) you entered are not linear.
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>1</name>
                <answertest>CasEqual</answertest>
                <sans>sa_contains_eigspace</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>2</truenextnode>
                <trueanswernote>prt_dvecs-2-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_dvecs-2-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    Your expression does not generate all the eigenvectors for \(\lambda={@double_eigval@}\).
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>2</name>
                <answertest>CasEqual</answertest>
                <sans>sa_dim</sans>
                <tans>2</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_dvecs-3-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_dvecs-3-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    Your expression includes vectors which are not eigenvectors for \(\lambda={@double_eigvec@}\) (other than the zero vector).
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <prt>
            <name>prt_xunit</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text>ans_xunit_norm:norm(list_matrix_entries(ans_xunit));
ans_xunit_ldep:is(rank(addcol(ans_xunit,single_normalized))=1);
ans_xunit_iszero:is(ans_xunit=zeromatrix(3,1));
</text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>ans_xunit_norm</sans>
                <tans>1</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>1</truenextnode>
                <trueanswernote>prt_xunit-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_xunit-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    Your vector has magnitude \({@ans_xunit_norm@}\neq 1\), so it is not a unit vector.
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>1</name>
                <answertest>CasEqual</answertest>
                <sans>ans_xunit_ldep</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_xunit-2-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_xunit-2-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    Your vector is not a multiple of the vector \(X\).
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>2</name>
                <answertest>CasEqual</answertest>
                <sans>ans_xunit_iszero</sans>
                <tans>false</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>0</truenextnode>
                <trueanswernote>prt_xunit-3-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_xunit-3-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    Your answer, the zero vector, is never an eigenvector (by definition).
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <deployedseed>1398395986</deployedseed>
        <deployedseed>2126924267</deployedseed>
        <deployedseed>964849467</deployedseed>
        <deployedseed>660783167</deployedseed>
        <deployedseed>1671484680</deployedseed>
        <deployedseed>1217184718</deployedseed>
        <deployedseed>1670946190</deployedseed>
        <deployedseed>574447874</deployedseed>
        <deployedseed>1514765764</deployedseed>
        <deployedseed>1003008478</deployedseed>
        <qtest>
            <testcase>1</testcase>
            <testinput>
                <name>ans_dvecs</name>
                <value>covect(gensol)</value>
            </testinput>
            <testinput>
                <name>ans_xunit</name>
                <value>single_normalized</value>
            </testinput>
            <expected>
                <name>prt_dvecs</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_dvecs-3-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_xunit</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_xunit-2-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>2</testcase>
            <testinput>
                <name>ans_dvecs</name>
                <value>ev(covect([s*t,s-t,r+t]),simp)</value>
            </testinput>
            <testinput>
                <name>ans_xunit</name>
                <value>zeromatrix(3,1)</value>
            </testinput>
            <expected>
                <name>prt_dvecs</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_dvecs-1-F</expectedanswernote>
            </expected>
            <expected>
                <name>prt_xunit</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_xunit-3-F</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>3</testcase>
            <testinput>
                <name>ans_dvecs</name>
                <value>ev(covect((s+t)*vecs[1]),simp)</value>
            </testinput>
            <testinput>
                <name>ans_xunit</name>
                <value>covect(single_eigvec)</value>
            </testinput>
            <expected>
                <name>prt_dvecs</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_dvecs-2-F</expectedanswernote>
            </expected>
            <expected>
                <name>prt_xunit</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_xunit-1-F</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>4</testcase>
            <testinput>
                <name>ans_dvecs</name>
                <value>matrix([s],[t],[r])</value>
            </testinput>
            <testinput>
                <name>ans_xunit</name>
                <value>covect([1,0,0]);</value>
            </testinput>
            <expected>
                <name>prt_dvecs</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_dvecs-3-F</expectedanswernote>
            </expected>
            <expected>
                <name>prt_xunit</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_xunit-2-F</expectedanswernote>
            </expected>
        </qtest>
    </question>
    <!-- question: 9134  -->
    <question type="stack">
        <name>
            <text>22.3.2.2 Pick symmetric matrices</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p class="HELM_exercise">
    <span class="multilang" lang="en">
        Exercise
    </span>
    <span class="multilang" lang="no">
        Øving
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        A matrix is called
        <strong>
            symmetric
        </strong>
        if is it symmetric across the main diagonal. In other words, transposing these matrices, i.e. interchanging their rows and columns, does not change them:
                \[A^T=A.\]
    </span>
    <span class="multilang" lang="no">
        En matrise kalles
        <strong>
            symmetrisk
        </strong>
        hvis den er symmetrisk over hoveddiagonalen. I andre ord, transponering av disse matrisene, dvs. bytting av rader og kolonner, endrer ikke matrisen:
                \[A^T=A.\]
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Select exactly the symmetric matrices:
    </span>
    <span class="multilang" lang="no">
        Velg nøyaktig de symmetriske matrisene:
    </span>
</p>
<p>
    [[input:ans_sym_list]] [[validation:ans_sym_list]] [[feedback:prt_sym_list]]
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        Let \(A = {@a4@}\). Then \(A^T = {@transpose(a4)@} \neq A\), therefore \(A\) is not symmetric.
    </span>
    <span class="multilang" lang="no">
        La \(A = {@a4@}\). Da er \(A^T = {@transpose(a4)@} \neq A\), altså er \(A\) ikke symmetrisk.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Let \(A = {@a5@}\). Then \(A^T = {@transpose(a5)@} = A\), therefore \(A\) is symmetric.
    </span>
    <span class="multilang" lang="no">
        La \(A = {@a5@}\). Da er \(A^T = {@transpose(a5)@} = A\), altså er \(A\) symmetrisk.
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Let \(A = {@a6@}\). Then \(A^T = {@transpose(a6)@} \neq A\), therefore \(A\) is not symmetric.
    </span>
    <span class="multilang" lang="no">
        La \(A = {@a6@}\). Da er \(A^T = {@transpose(a6)@} \neq A\), altså er \(A\) ikke symmetrisk.
    </span>
</p>
]]></text>
        </generalfeedback>
        <defaultgrade>1.0000000</defaultgrade>
        <penalty>0.1000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
        <stackversion>
            <text>2023010400</text>
        </stackversion>
        <questionvariables>
            <text>maxn : 9;
a1 : matrixmap(lambda([ex],rand_with_step(-maxn,maxn,1)), zeromatrix(2,2));
a1[2,1] : a1[1,2];  /* symmetric now */
a2 : matrixmap(lambda([ex],rand_with_step(-maxn,maxn,1)), zeromatrix(2,2));
a2[2,1] : rand_with_prohib(-maxn,maxn,[a2[1,2]]); /* make sure it's not symmetric */
a3 : matrixmap(lambda([ex],rand_with_step(-maxn,maxn,1)), zeromatrix(3,3));
a3[2,1] : a3[1,2]; a3[3,1] : a3[1,3]; a3[3,2] : a3[2,3];  /* symmetric now */
a4 : matrixmap(lambda([ex],rand_with_step(-maxn,maxn,1)), zeromatrix(3,3));
a4[3,2] : rand_with_prohib(-maxn,maxn,[a4[2,3]]); /* make sure it's not symmetric */
v : rand_with_step(-maxn,maxn,1);
/* a5 : genmatrix(lambda([i,j],v), 3, 3); */
a5: zeromatrix(2,2);
a6 : matrixmap(lambda([ex],rand_with_step(-maxn,maxn,1)), zeromatrix(2,2));
a6[1,1] : a6[2,2]; a6[1,2] = rand_with_prohib(-maxn,maxn,[a6[2,1]]) /* make sure it's wrong symmetric */

ta : random_permutation([ [a1,true], [a2,false], [a3,true], [a4,false], [a5,true], [a6,false] ]);
</text>
        </questionvariables>
        <specificfeedback format="html">
            <text></text>
        </specificfeedback>
        <questionnote>
            <text>\({@ta@}, {@ta[1][1]@}\)</text>
        </questionnote>
        <questionsimplify>1</questionsimplify>
        <assumepositive>0</assumepositive>
        <assumereal>0</assumereal>
        <prtcorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:green;">
    <i class="fa fa-check">
    </i>
</span>
Correct answer, well done.
]]></text>
        </prtcorrect>
        <prtpartiallycorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:orange;">
    <i class="fa fa-adjust">
    </i>
</span>
Your answer is partially correct.
]]></text>
        </prtpartiallycorrect>
        <prtincorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:red;">
    <i class="fa fa-times">
    </i>
</span>
Incorrect answer.
]]></text>
        </prtincorrect>
        <multiplicationsign>dot</multiplicationsign>
        <sqrtsign>1</sqrtsign>
        <complexno>i</complexno>
        <inversetrig>cos-1</inversetrig>
        <logicsymbol>lang</logicsymbol>
        <matrixparens>[</matrixparens>
        <variantsselectionseed></variantsselectionseed>
        <input>
            <name>ans_sym_list</name>
            <type>checkbox</type>
            <tans>ta</tans>
            <boxsize>15</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>0</mustverify>
            <showvalidation>0</showvalidation>
            <options></options>
        </input>
        <prt>
            <name>prt_sym_list</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text></text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>Sets</answertest>
                <sans>setify(ans_sym_list)</sans>
                <tans>setify(mcq_correct(ta))</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt1-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt1-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
        </prt>
        <deployedseed>1433076699</deployedseed>
        <deployedseed>1058758573</deployedseed>
        <deployedseed>901623094</deployedseed>
        <deployedseed>1671088752</deployedseed>
        <deployedseed>1484152529</deployedseed>
        <deployedseed>526454197</deployedseed>
        <deployedseed>494657264</deployedseed>
        <deployedseed>426499238</deployedseed>
        <deployedseed>759140100</deployedseed>
        <deployedseed>1011563060</deployedseed>
        <qtest>
            <testcase>1</testcase>
            <testinput>
                <name>ans_sym_list</name>
                <value>mcq_correct(ta)</value>
            </testinput>
            <expected>
                <name>prt_sym_list</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt1-1-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>2</testcase>
            <testinput>
                <name>ans_sym_list</name>
                <value>[matrix([0,0],[0,0])]</value>
            </testinput>
            <expected>
                <name>prt_sym_list</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt1-1-F</expectedanswernote>
            </expected>
        </qtest>
    </question>
    <!-- question: 9135  -->
    <question type="stack">
        <name>
            <text>22.3.2.4 Complex conjugate 2x2 eigentask</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p class="HELM_exercise">
    <span class="multilang" lang="en">
        Exercise
    </span>
    <span class="multilang" lang="no">
        Øving
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Consider the non-symmetric matrix
                \[A={@m@}.\]
                Obtain the eigenvalues of \(A\):
    </span>
    <span class="multilang" lang="no">
        Betrakt matrisen
                                \[A={@m@}.\]
                                Finn egenverdiene til \(A\):
    </span>
</p>
<div>
    [[input:anseigenvalues]] [[validation:anseigenvalues]] [[feedback:prt_eigenvalues]]
</div>
<p>
</p>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The characteristic equation of \(A\) is \[\det( A-\lambda I ) = {@(lmxchar:"|",a-lambda*ident(2))@} = 0,\] i.e. \[{@(lmxchar:saved_lmxchar, charpoly_raw)@} = 0\] leading to \[{@charpoly_simp@}=0,\] giving eigenvalues \({@eigvals[1,1]@}\) and \({@eigvals[1,2]@}\).
                These are clearly
        <strong>
            complex conjugate
        </strong>
        .
    </span>
    <span class="multilang" lang="no">
        Den karakteristiske likningen til \(A\) er \[\det( A-\lambda I ) = {@(lmxchar:"|",a-lambda*ident(2))@} = 0,\] dvs. \[{@(lmxchar:saved_lmxchar, charpoly_raw)@} = 0\] som fører til \[{@charpoly_simp@}=0,\] som gir egenverdier \({@eigvals[1,1]@}\) og \({@eigvals[1,2]@}\).
                Disse er tydeligvis
        <strong>
            komplekst konjugerte
        </strong>
        .
    </span>
</p>
]]></text>
        </generalfeedback>
        <defaultgrade>1.0000000</defaultgrade>
        <penalty>0.1000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
        <stackversion>
            <text>2023010400</text>
        </stackversion>
        <questionvariables>
            <text>/* Generate a 2x2 matrix with complex eigenvalues */
a : rand_with_prohib(-5,5,[0]); d : -a; /* choose a,d so that a+d is even */
imp : 1+rand(4);  /* imaginary part of an eigval */
/* choose b,c so that bc=ad-(a+d)^2/4-imp^2 */
bc : a*d - 1/4 * (a+d)^2 - imp^2;
b : (if primep(bc) then 1 else first(flatten(ifactors(abs(bc))))) *rand([-1,1]);
c : bc / b;
m : matrix([a,b],[c,d]);
eigvals : matrix([ (a+d)/2 + sqrt(-1)*imp, (a+d)/2 - sqrt(-1)*imp ]);

/* prepare for printing the solution */
charpoly_raw : charpoly(m,lambda);
charpoly_simp : simplify(charpoly_raw);

/* save original lmxchar */
saved_lmxchar : lmxchar;</text>
        </questionvariables>
        <specificfeedback format="html">
            <text></text>
        </specificfeedback>
        <questionnote>
            <text>\(A = {@m@}, \qquad \lambda = {@eigvals[1,1]@}, {@eigvals[1,2]@}\)</text>
        </questionnote>
        <questionsimplify>1</questionsimplify>
        <assumepositive>0</assumepositive>
        <assumereal>0</assumereal>
        <prtcorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:green;">
    <i class="fa fa-check">
    </i>
</span>
Correct answer, well done.
]]></text>
        </prtcorrect>
        <prtpartiallycorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:orange;">
    <i class="fa fa-adjust">
    </i>
</span>
Your answer is partially correct.
]]></text>
        </prtpartiallycorrect>
        <prtincorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:red;">
    <i class="fa fa-times">
    </i>
</span>
Incorrect answer.
]]></text>
        </prtincorrect>
        <multiplicationsign>none</multiplicationsign>
        <sqrtsign>1</sqrtsign>
        <complexno>i</complexno>
        <inversetrig>cos-1</inversetrig>
        <logicsymbol>lang</logicsymbol>
        <matrixparens>[</matrixparens>
        <variantsselectionseed></variantsselectionseed>
        <input>
            <name>anseigenvalues</name>
            <type>matrix</type>
            <tans>eigvals</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <prt>
            <name>prt_eigenvalues</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text>got_ev1 : member(anseigenvalues[1,1], eigvals[1]);
got_ev2 : member(anseigenvalues[1,2], eigvals[1]);</text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>got_ev1</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>0.5000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>1</truenextnode>
                <trueanswernote>prt1-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>1</falsenextnode>
                <falseanswernote>prt1-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You didn't identify \({@eigvals[1,1]@}\) as an eigenvalue.
    </span>
    <span class="multilang" lang="no">
        Du identifiserte ikke \({@eigvals[1,1]@}\) som en egenverdi.
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>1</name>
                <answertest>CasEqual</answertest>
                <sans>got_ev2</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.5000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt1-2-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt1-2-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You didn't identify \({@eigvals[1,2]@}\) as an eigenvalue.
    </span>
    <span class="multilang" lang="no">
        Du identifiserte ikke \({@eigvals[1,2]@}\) som en egenverdi.
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <deployedseed>1791513702</deployedseed>
        <deployedseed>122062414</deployedseed>
        <deployedseed>1615884555</deployedseed>
        <deployedseed>1745714007</deployedseed>
        <deployedseed>412712207</deployedseed>
        <deployedseed>995194110</deployedseed>
        <deployedseed>1507220549</deployedseed>
        <deployedseed>1803901398</deployedseed>
        <deployedseed>76367518</deployedseed>
        <deployedseed>1752147708</deployedseed>
        <qtest>
            <testcase>1</testcase>
            <testinput>
                <name>anseigenvalues</name>
                <value>eigvals</value>
            </testinput>
            <expected>
                <name>prt_eigenvalues</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt1-2-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>2</testcase>
            <testinput>
                <name>anseigenvalues</name>
                <value>matrix([0,0])</value>
            </testinput>
            <expected>
                <name>prt_eigenvalues</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt1-2-F</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>3</testcase>
            <testinput>
                <name>anseigenvalues</name>
                <value>ev(matrix([eigvals[1,2],eigvals[1,1]+1]),simp)</value>
            </testinput>
            <expected>
                <name>prt_eigenvalues</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt1-2-F</expectedanswernote>
            </expected>
        </qtest>
    </question>
    <!-- question: 9136  -->
    <question type="stack">
        <name>
            <text>22.3.2.6 Symmetric 2x2 eigentask</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p class="HELM_exercise">
    <span class="multilang" lang="en">
        Exercise
    </span>
    <span class="multilang" lang="no">
        Øving
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Consider the \(2\times 2\) symmetric matrix \[A={@m@}.\]
    </span>
    <span class="multilang" lang="no">
        Se på den \(2\times 2\) symmetriske matrisen \[A={@m@}.\]
    </span>
</p>
<ol class="HELM_parts">
    <li>
        <div>
            <span class="multilang" lang="en">
                Find the eigenvalues of \(A\):
            </span>
            <span class="multilang" lang="no">
                Finn egenverdiene til \(A\):
            </span>
            [[input:anseigenvalues]] [[validation:anseigenvalues]]
        </div>
        [[feedback:prt_eigenvalues]]
    </li>
    <li>
        <div>
            <span class="multilang" lang="en">
                Find (independent) eigenvectors of \(A\): \(X=\)
            </span>
            <span class="multilang" lang="no">
                Finn (uavhengige) egenvektorer til \(A\): \(X=\)
            </span>
            [[input:anseig_x]] [[validation:anseig_x]]  and \(Y=\) [[input:anseig_y]] [[validation:anseig_y]]
        </div>
        [[feedback:prt_eigenvectors]]
    </li>
    <li>
        <div>
            <span class="multilang" lang="en">
                For the two eigenvectors found above, evaluate \(X^TY=\)
            </span>
            <span class="multilang" lang="no">
                For de to egenvektorene som ble funnet ovenfor, beregn \(X^TY=\)
            </span>
            [[input:ansprod]] [[validation:ansprod]]
        </div>
        [[feedback:prt_dotprod]]
    </li>
</ol>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text><![CDATA[
<ol class="HELM_parts">
    <li>
        <p>
            <span class="multilang" lang="en">
                The characteristic equation for \(A\) is \[{@charpoly_raw@}=0\qquad\text{or}\qquad{@charpoly_simp@}=0,\] giving \(\lambda={@eigvaly@}\) and \(\lambda={@eigvalx@}\), both of which are of course real and also unequal (i.e. distinct).
            </span>
            <span class="multilang" lang="no">
                Den karakteristiske likningen for \(A\) er \[{@charpoly_raw@}=0\qquad\text{eller}\qquad{@charpoly_simp@}=0,\] som gir \(\lambda={@eigvaly@}\) og \(\lambda={@eigvalx@}\), begge er selvfølgelig reelle og også ulike (dvs. distinkte).
            </span>
        </p>
    </li>
    <li>
        <p>
            <span class="multilang" lang="en">
                For the larger eigenvalue \(\lambda={@eigvalx@}\) the eigenvector \(X={@matrix([x],[y])@}\) satisfies \[{@m@}{@matrix([x],[y])@} = {@eigvalx*matrix([x],[y])@}.\] Both equations simplify to \({@-eigvecx[2,1]*x+eigvecx[1,1]*y@}=0\), so an eigenvector
                                                for \(\lambda={@eigvalx@}\) is \(X={@eigvecx@}\) or any non-zero multiple of it.
            </span>
            <span class="multilang" lang="no">
                For den større egenverdien \(\lambda={@eigvalx@}\) så er egenvektoren \(X={@matrix([x],[y])@}\) som oppfyller \[{@m@}{@matrix([x],[y])@} = {@eigvalx*matrix([x],[y])@}.\] Begge likningene forenkles til \({@-eigvecx[2,1]*x+eigvecx[1,1]*y@}=0\), så en egenvektor for \(\lambda={@eigvalx@}\) er \(X={@eigvecx@}\) eller en hvilken som helst ikke-null multiplum av den.
            </span>
        </p>
        <p>
            <span class="multilang" lang="en">
                For \(\lambda={@eigvaly@}\) the associated eigenvectors satisfy \({@-eigvecy[2,1]*x+eigvecy[1,1]*y@}=0\) (from both equations), so an eigenvector is \(Y={@eigvecy@}\) or any non-zero multiple.
            </span>
            <span class="multilang" lang="no">
                For \(\lambda={@eigvaly@}\) så oppfyller de tilhørende egenvektorene \({@-eigvecy[2,1]*x+eigvecy[1,1]*y@}=0\) (fra begge likningene), så en egenvektor er \(Y={@eigvecy@}\) eller en hvilken som helst ikke-null multiplum av den.
            </span>
        </p>
    </li>
    <li>
        <p>
            <span class="multilang" lang="en">
                We compute \[X^TY = {@transpose(eigvecx)@}{@eigvecy@} = {@(simp:false,make_multsgn("cross"),prodcomp)@} = {@(simp:true,zeromatrix(1,1))@} = \mathbf{0}.\] The relation \(X^TY = \mathbf{0}\) means that \(X\) and \(Y\) are
                <strong>
                    orthogonal
                </strong>
                .
            </span>
            <span class="multilang" lang="no">
                Vi beregner \[X^TY = {@transpose(eigvecx)@}{@eigvecy@} = {@(simp:false,make_multsgn("cross"),prodcomp)@} = {@(simp:true,zeromatrix(1,1))@} = \mathbf{0}.\] Relasjonen \(X^TY = \mathbf{0}\) betyr at \(X\) og \(Y\) er
                <strong>
                    ortogonale
                </strong>
                .
            </span>
        </p>
    </li>
</ol>
]]></text>
        </generalfeedback>
        <defaultgrade>3.0000000</defaultgrade>
        <penalty>0.1000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
        <stackversion>
            <text>2023010400</text>
        </stackversion>
        <questionvariables>
            <text><![CDATA[/* Generate a 2x2 symmetric matrix with nice eigenvalues/eigenvectors */
/* From: https://www.researchgate.net/publication/228855146_Setting_linear_algebra_problems */
[a,b]:rand_selection([-2,-1,1,2],2);
kk:1; /* the eigvals will be kk*(a^2+b^2) apart */
m : kk*matrix([b*b,a*b],[a*b,a*a]);  /* eigvals are 0, kk*(a^2+b^2) */
tt : rand_with_step(0,kk*a*a+kk*b*b,1);
m : m - tt*ident(2);  /* can shift by any*ident(2) */

gg : gcd(a,b);
eigvecy : matrix([a/gg],[-b/gg]); if a<0 then eigvecy : -eigvecy;
eigvecx : matrix([b/gg],[a/gg]); if b<0 then eigvecx : -eigvecx;
eigvaly : -tt;
eigvalx : kk*a*a+kk*b*b-tt;
eigvalmat : matrix([eigvalx,eigvaly]);

/* Preparing for printing the solution */
charpoly_raw : charpoly(m,lambda);
charpoly_simp : simplify(charpoly_raw);
simp:false;
prodcomp: matrix([eigvecx[1,1]*eigvecy[1,1] + eigvecx[2,1]*eigvecy[2,1]]);
simp:true;
]]></text>
        </questionvariables>
        <specificfeedback format="html">
            <text></text>
        </specificfeedback>
        <questionnote>
            <text>\(A = {@m@}, \qquad \lambda = {@eigvaly@}, {@eigvalx@}, \qquad \text{eigenvectors} \; Y = {@eigvecy@}, X = {@eigvecx@}\)</text>
        </questionnote>
        <questionsimplify>1</questionsimplify>
        <assumepositive>0</assumepositive>
        <assumereal>0</assumereal>
        <prtcorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:green;">
    <i class="fa fa-check">
    </i>
</span>
Correct answer, well done.
]]></text>
        </prtcorrect>
        <prtpartiallycorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:orange;">
    <i class="fa fa-adjust">
    </i>
</span>
Your answer is partially correct.
]]></text>
        </prtpartiallycorrect>
        <prtincorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:red;">
    <i class="fa fa-times">
    </i>
</span>
Incorrect answer.
]]></text>
        </prtincorrect>
        <multiplicationsign>dot</multiplicationsign>
        <sqrtsign>1</sqrtsign>
        <complexno>i</complexno>
        <inversetrig>cos-1</inversetrig>
        <logicsymbol>lang</logicsymbol>
        <matrixparens>[</matrixparens>
        <variantsselectionseed></variantsselectionseed>
        <input>
            <name>anseig_x</name>
            <type>matrix</type>
            <tans>eigvecx</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <input>
            <name>anseig_y</name>
            <type>matrix</type>
            <tans>eigvecy</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <input>
            <name>anseigenvalues</name>
            <type>matrix</type>
            <tans>eigvalmat</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <input>
            <name>ansprod</name>
            <type>matrix</type>
            <tans>matrix([0])</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <prt>
            <name>prt_dotprod</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text>simp:false;
prod_from_xy_raw : anseig_x[1,1]*anseig_y[1,1]+anseig_x[2,1]*anseig_y[2,1];
simp:true;
prod_from_xy : simplify(prod_from_xy_raw);
anspair : [is(prod_from_xy=ansprod[1,1]), is(ansprod[1,1]=0)];</text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>anspair</sans>
                <tans>[true,true]</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_dotprod-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>1</falsenextnode>
                <falseanswernote>prt_dotprod-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
            <node>
                <name>1</name>
                <answertest>CasEqual</answertest>
                <sans>anspair</sans>
                <tans>[false,true]</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>0.5000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_dotprod-2-T</trueanswernote>
                <truefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        Your answer \({@zeromatrix(1,1)@}\) is the correct one for the actual eigenvectors of \(A\), but does not match the vectors \(X,Y\) you determined, since \(X^TY={@transpose(anseig_x)@}{@anseig_y@}= {@(simp:false,make_multsgn("cross"),matrix([prod_from_xy_raw]))@} = {@(simp:true,matrix([prod_from_xy]))@}\).
    </span>
    <span class="multilang" lang="no">
        Svaret ditt \({@zeromatrix(1,1)@}\) er den riktige for de faktiske egenvektorene til \(A\), men samsvarer ikke med vektorene \(X^TY={@transpose(anseig_x)@}{@anseig_y@}= {@(simp:false,make_multsgn("cross"),matrix([prod_from_xy_raw]))@} = {@(simp:true,matrix([prod_from_xy]))@}\)
    </span>
</p>
]]></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>2</falsenextnode>
                <falseanswernote>prt_dotprod-2-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
            <node>
                <name>2</name>
                <answertest>CasEqual</answertest>
                <sans>anspair</sans>
                <tans>[true,false]</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_dotprod-3-T</trueanswernote>
                <truefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You have computed \(X^TY = {@matrix([prod_from_xy])@}\) from your vectors \(X\) and \(Y\) correctly, but please see the Answer: for the actual eigenvectors of \(A\) this product is \({@zeromatrix(1,1)@}\), i.e. the eigenvectors are orthogonal.
    </span>
    <span class="multilang" lang="no">
        Du har beregnet \(X^TY = {@matrix([prod_from_xy])@}\) fra vektorene dine \(X\) og \(Y\) riktig, men svaret for de faktiske egenvektorene til \(A\) er produktet \({@zeromatrix(1,1)@}\), dvs. egenvektorene er ortogonale.
    </span>
</p>
]]></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_dotprod-3-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        For your vectors \(X\) and \(Y\), we have \(X^TY={@transpose(anseig_x)@}{@anseig_y@}={@(simp:false,make_multsgn("cross"),matrix([prod_from_xy_raw]))@} = {@(simp:true,matrix([prod_from_xy]))@} \neq {@ansprod@}\).
    </span>
    <span class="multilang" lang="no">
        For dine vektorer \(X\) og \(Y\), har vi \(X^TY={@transpose(anseig_x)@}{@anseig_y@}={@(simp:false,make_multsgn("cross"),matrix([prod_from_xy_raw]))@} = {@(simp:true,matrix([prod_from_xy]))@} \neq {@ansprod@}\).
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <prt>
            <name>prt_eigenvalues</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text>got_first : member(eigvalx, anseigenvalues[1]);
got_second : member(eigvaly, anseigenvalues[1]);</text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>got_first</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>0.5000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>1</truenextnode>
                <trueanswernote>prt_eigenvalues-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>1</falsenextnode>
                <falseanswernote>prt_eigenvalues-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You didn't find \({@eigvalx@}\) as an eigenvalue.
    </span>
    <span class="multilang" lang="no">
        Du fant ikke \({@eigvalx@}\) som en egenverdi.
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>1</name>
                <answertest>CasEqual</answertest>
                <sans>got_second</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.5000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_eigenvalues-2-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_eigenvalues-2-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        You didn't find \({@eigvaly@}\) as an eigenvalue.
    </span>
    <span class="multilang" lang="no">
        Du fant ikke \({@eigvaly@}\) som en egenverdi.
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <prt>
            <name>prt_eigenvectors</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text>ax_eigvec_eval : [is(zeromatrix(2,1) = (m-eigvalx*ident(2)) . anseig_x), is(zeromatrix(2,1) = (m-eigvaly*ident(2)) . anseig_x),  is(zeromatrix(2,1)=anseig_x)];
ay_eigvec_eval : [is(zeromatrix(2,1) = (m-eigvalx*ident(2)) . anseig_y), is(zeromatrix(2,1) = (m-eigvaly*ident(2)) . anseig_y),  is(zeromatrix(2,1)=anseig_y)];

all_zero : ax_eigvec_eval[3] and ay_eigvec_eval[3];
ax_is_eigvec : (ax_eigvec_eval[1] or  ax_eigvec_eval[2]) and not(ax_eigvec_eval[3]);
ay_is_eigvec : (ay_eigvec_eval[1] or  ay_eigvec_eval[2]) and not(ay_eigvec_eval[3]);
are_nz_dependent : is(rank(addcol(anseig_x,anseig_y))=1) and ax_is_eigvec and ay_is_eigvec and not(ax_eigvec_eval[3]) and not(ay_eigvec_eval[3]);
</text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>CasEqual</answertest>
                <sans>all_zero</sans>
                <tans>false</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>=</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>1</truenextnode>
                <trueanswernote>prt_eigenvectors-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_eigenvectors-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The zero vector is never an eigenvector of any matrix (by definition).
    </span>
    <span class="multilang" lang="no">
        Nullvektoren er aldri en egenvektor for hviklen som helst matrise (ved definisjon).
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>1</name>
                <answertest>CasEqual</answertest>
                <sans>ax_is_eigvec</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.5000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>2</truenextnode>
                <trueanswernote>prt_eigenvectors-2-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>2</falsenextnode>
                <falseanswernote>prt_eigenvectors-2-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The vector \(X={@anseig_x@}\) is not an eigenvector of \(A\).
    </span>
    <span class="multilang" lang="no">
        Vektoren \(X={@anseig_x@}\) er ikke en egenvektor av \(A\).
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>2</name>
                <answertest>CasEqual</answertest>
                <sans>ay_is_eigvec</sans>
                <tans>true</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.5000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>3</truenextnode>
                <trueanswernote>prt_eigenvectors-3-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>3</falsenextnode>
                <falseanswernote>prt_eigenvectors-3-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The vector \(Y={@anseig_y@}\) is not an eigenvector of \(A\).
    </span>
    <span class="multilang" lang="no">
        Vektoren \(Y={@anseig_y@}\) er ikke en egenvektor for \(A\).
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
            <node>
                <name>3</name>
                <answertest>CasEqual</answertest>
                <sans>are_nz_dependent</sans>
                <tans>false</tans>
                <testoptions></testoptions>
                <quiet>1</quiet>
                <truescoremode>+</truescoremode>
                <truescore>0.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_eigenvectors-4-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>-</falsescoremode>
                <falsescore>0.5000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_eigenvectors-4-F</falseanswernote>
                <falsefeedback format="html">
                    <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        The two vectors \(X\) and \(Y\) are linearly dependent (one of them is a multiple of the other). Thus they are eigenvectors for the same eigenvalue, and you are missing another independent eigenvector.
    </span>
    <span class="multilang" lang="no">
        De to vektorene \(X\) og \(Y\) er lineært avhengige (en av dem er en multiplum av den andre). Dermed er de egenvektorer for samme egenverdi, og du mangler en annen uavhengig egenvektor.
    </span>
</p>
]]></text>
                </falsefeedback>
            </node>
        </prt>
        <deployedseed>1840622559</deployedseed>
        <deployedseed>1374245326</deployedseed>
        <deployedseed>2050662052</deployedseed>
        <deployedseed>904461369</deployedseed>
        <deployedseed>454547234</deployedseed>
        <deployedseed>1520403740</deployedseed>
        <deployedseed>1767821257</deployedseed>
        <deployedseed>943622216</deployedseed>
        <deployedseed>307422312</deployedseed>
        <deployedseed>245396139</deployedseed>
        <qtest>
            <testcase>1</testcase>
            <testinput>
                <name>anseig_x</name>
                <value>eigvecx</value>
            </testinput>
            <testinput>
                <name>anseig_y</name>
                <value>eigvecy</value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>eigvalmat</value>
            </testinput>
            <testinput>
                <name>ansprod</name>
                <value>matrix([0])</value>
            </testinput>
            <expected>
                <name>prt_dotprod</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_dotprod-1-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvalues</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_eigenvalues-2-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvectors</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_eigenvectors-4-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>2</testcase>
            <testinput>
                <name>anseig_x</name>
                <value>ev(eigvecx+matrix([1000],[1000000]),simp)</value>
            </testinput>
            <testinput>
                <name>anseig_y</name>
                <value>ev(eigvecy+matrix([1000],[1000000]),simp)</value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>ev(eigvalmat+matrix([1000,1000]),simp)</value>
            </testinput>
            <testinput>
                <name>ansprod</name>
                <value>matrix([100])</value>
            </testinput>
            <expected>
                <name>prt_dotprod</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_dotprod-3-F</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvalues</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_eigenvalues-2-F</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvectors</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_eigenvectors-4-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>3</testcase>
            <testinput>
                <name>anseig_x</name>
                <value>eigvecy</value>
            </testinput>
            <testinput>
                <name>anseig_y</name>
                <value>ev(eigvecx+matrix([1000],[1000]),simp)</value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>ev(eigvalmat+matrix([0,1000]),simp)</value>
            </testinput>
            <testinput>
                <name>ansprod</name>
                <value>ev(matrix([transpose(eigvecx+matrix([1000],[1000])) . eigvecy]) ,simp)</value>
            </testinput>
            <expected>
                <name>prt_dotprod</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_dotprod-3-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvalues</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_eigenvalues-2-F</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvectors</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_eigenvectors-4-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>4</testcase>
            <testinput>
                <name>anseig_x</name>
                <value>ev(eigvecx+matrix([1000],[1000]),simp)</value>
            </testinput>
            <testinput>
                <name>anseig_y</name>
                <value>eigvecy</value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>ev(eigvalmat+matrix([1000,0]),simp)</value>
            </testinput>
            <testinput>
                <name>ansprod</name>
                <value>matrix([0])</value>
            </testinput>
            <expected>
                <name>prt_dotprod</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_dotprod-2-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvalues</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_eigenvalues-2-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvectors</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_eigenvectors-4-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>5</testcase>
            <testinput>
                <name>anseig_x</name>
                <value>eigvecx</value>
            </testinput>
            <testinput>
                <name>anseig_y</name>
                <value>ev(3*eigvecx,simp)</value>
            </testinput>
            <testinput>
                <name>anseigenvalues</name>
                <value>eigvalmat</value>
            </testinput>
            <testinput>
                <name>ansprod</name>
                <value>matrix([0])</value>
            </testinput>
            <expected>
                <name>prt_dotprod</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_dotprod-2-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvalues</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_eigenvalues-2-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_eigenvectors</name>
                <expectedscore>0.5000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_eigenvectors-4-F</expectedanswernote>
            </expected>
        </qtest>
    </question>
    <!-- question: 9137  -->
    <question type="stack">
        <name>
            <text>22.3.2.8 Eigvecs of 3x3 symmetric are orthogonal</text>
        </name>
        <questiontext format="html">
            <text><![CDATA[
<p class="HELM_exercise">
    <span class="multilang" lang="en">
        Exercise
    </span>
    <span class="multilang" lang="no">
        Øving
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Consider the matrix \[A={@a@},\] which is, we emphasize,
        <strong>
            symmetric
        </strong>
        . Its eigenvalues are \({@eigvals[1]@}, {@eigvals[2]@}, {@eigvals[3]@}\), and the eigenvectors are, respectively,
                \[X={@eigvecs[1]@},\qquad Y={@eigvecs[2]@},\qquad Z={@eigvecs[3]@}\] (or, as usual, any non-zero multiple of them).
    </span>
    <span class="multilang" lang="no">
        Vi betrakter matrisen \[A={@a@},\] som er, understreket,
        <strong>
            symmetrisk
        </strong>
        . Matrisens egenverdier er \({@eigvals[1]@}, {@eigvals[2]@}, {@eigvals[3]@}\), og egenvektorene er, henholdsvis,
                \[X={@eigvecs[1]@},\qquad Y={@eigvecs[2]@},\qquad Z={@eigvecs[3]@}\] (eller, som vanlig, hvilken som helst ikke-null multiplum av dem).
    </span>
</p>
<p>
    <span class="multilang" lang="en">
        Compute the following quantities:
    </span>
    <span class="multilang" lang="no">
        Beregn følgende kvantiteter:
    </span>
</p>
<div>
    \(X^TY=\) [[input:ans_xy]] [[validation:ans_xy]]
</div>
<div>
    [[feedback:prt_xy]]
</div>
<div>
    <br/>
</div>
<div>
    \(Y^TZ=\) [[input:ans_yz]] [[validation:ans_yz]]
</div>
<div>
    [[feedback:prt_yz]]
</div>
<div>
    <br/>
</div>
<div>
    \(Z^TX=\) [[input:ans_zx]] [[validation:ans_zx]]
</div>
<div>
    [[feedback:prt_zx]]
</div>
]]></text>
        </questiontext>
        <generalfeedback format="html">
            <text><![CDATA[
<p>
    <span class="multilang" lang="en">
        \[X^TY = {@transpose(eigvecs[1])@}{@eigvecs[2]@} = {@(simp:false,make_multsgn("cross"),xy_comp1)@} = {@xy_comp2@} = \mathbf{0}\] \[Y^TZ = {@transpose(eigvecs[2])@}{@eigvecs[3]@} = {@yz_comp1@} = {@yz_comp2@} = \mathbf{0}\] \[Z^TX = {@transpose(eigvecs[3])@}{@eigvecs[1]@}
                = {@zx_comp1@} = {@zx_comp2@} = \mathbf{0}\] Thus the three eigenvectors \(X,Y,Z\) are
        <strong>
            mutually orthogonal
        </strong>
        .
    </span>
    <span class="multilang" lang="no">
        \[X^TY = {@transpose(eigvecs[1])@}{@eigvecs[2]@} = {@(simp:false,make_multsgn("cross"),xy_comp1)@} = {@xy_comp2@} = \mathbf{0}\] \[Y^TZ = {@transpose(eigvecs[2])@}{@eigvecs[3]@} = {@yz_comp1@} = {@yz_comp2@} = \mathbf{0}\] \[Z^TX = {@transpose(eigvecs[3])@}{@eigvecs[1]@}
                = {@zx_comp1@} = {@zx_comp2@} = \mathbf{0}\] Dermed er de tre egenvektorene \(X,Y,Z\)
        <strong>
            ortogonale
        </strong>
        .
    </span>
</p>
]]></text>
        </generalfeedback>
        <defaultgrade>3.0000000</defaultgrade>
        <penalty>0.1000000</penalty>
        <hidden>0</hidden>
        <idnumber></idnumber>
        <stackversion>
            <text>2023010400</text>
        </stackversion>
        <questionvariables>
            <text><![CDATA[/* static list of 0,±1-valued 3x3 symmetric matrices with 1 integer eigenvalue */
permmats:[matrix([1,0,0],[0,1,0],[0,0,1]),matrix([1,0,0],[0,0,1],[0,1,0]),matrix([0,0,1],[1,0,0],[0,1,0]),matrix([0,0,1],[0,1,0],[1,0,0]),matrix([0,1,0],[0,0,1],[1,0,0]),matrix([0,1,0],[1,0,0],[0,0,1])];
use_mats:[matrix([-2,-2,-2],[-2,-2,0],[-2,0,-2]),matrix([-2,-2,-2],[-2,-2,1],[-2,1,0]),matrix([-2,-2,-2],[-2,-1,-1],[-2,-1,1]),matrix([-2,-2,-2],[-2,-1,2],[-2,2,1]),matrix([-2,-2,-2],[-2,0,2],[-2,2,0]),matrix([-2,-2,-2],[-2,1,-1],[-2,-1,2]),matrix([-2,-2,-2],[-2,1,1],[-2,1,1]),matrix([-2,-2,-1],[-2,-2,-1],[-1,-1,-2]),matrix([-2,-2,-1],[-2,-2,-1],[-1,-1,0]),matrix([-2,-2,-1],[-2,-2,0],[-1,0,-2]),matrix([-2,-2,-1],[-2,-2,1],[-1,1,-2]),matrix([-2,-2,-1],[-2,-2,1],[-1,1,0]),matrix([-2,-2,-1],[-2,-2,1],[-1,1,2]),matrix([-2,-2,-1],[-2,-2,2],[-1,2,0]),matrix([-2,-2,-1],[-2,-1,-2],[-1,-2,2]),matrix([-2,-2,-1],[-2,-1,0],[-1,0,0]),matrix([-2,-2,-1],[-2,0,-2],[-1,-2,0]),matrix([-2,-2,-1],[-2,0,-1],[-1,-1,1]),matrix([-2,-2,-1],[-2,0,0],[-1,0,0]),matrix([-2,-2,-1],[-2,1,-2],[-1,-2,-2]),matrix([-2,-2,-1],[-2,1,-2],[-1,-2,2]),matrix([-2,-2,-1],[-2,1,2],[-1,2,2]),matrix([-2,-2,-1],[-2,2,1],[-1,1,-2]),matrix([-2,-2,-1],[-2,2,1],[-1,1,-1]),matrix([-2,-2,0],[-2,-1,-1],[0,-1,1]),matrix([-2,-2,0],[-2,0,-2],[0,-2,2]),matrix([-2,-2,0],[-2,2,2],[0,2,-2]),matrix([-2,-2,1],[-2,-2,1],[1,1,0]),matrix([-2,-2,1],[-2,-2,1],[1,1,2]),matrix([-2,-2,1],[-2,0,1],[1,1,1]),matrix([-2,-2,1],[-2,0,2],[1,2,1]),matrix([-2,-2,1],[-2,1,-2],[1,-2,2]),matrix([-2,-2,1],[-2,1,2],[1,2,-2]),matrix([-2,-2,1],[-2,2,-1],[1,-1,-1]),matrix([-2,-2,1],[-2,2,1],[1,1,2]),matrix([-2,-2,2],[-2,-1,1],[2,1,1]),matrix([-2,-2,2],[-2,1,-1],[2,-1,1]),matrix([-2,-2,2],[-2,1,1],[2,1,-1]),matrix([-2,-1,-1],[-1,-2,-1],[-1,-1,1]),matrix([-2,-1,-1],[-1,-2,1],[-1,1,-1]),matrix([-2,-1,-1],[-1,-1,1],[-1,1,2]),matrix([-2,-1,-1],[-1,0,2],[-1,2,0]),matrix([-2,-1,-1],[-1,1,-1],[-1,-1,2]),matrix([-2,-1,-1],[-1,1,1],[-1,1,2]),matrix([-2,-1,-1],[-1,2,0],[-1,0,2]),matrix([-2,-1,0],[-1,-2,2],[0,2,-2]),matrix([-2,-1,0],[-1,-1,1],[0,1,0]),matrix([-2,-1,0],[-1,0,2],[0,2,-1]),matrix([-2,-1,0],[-1,0,2],[0,2,1]),matrix([-2,-1,1],[-1,-2,2],[1,2,-2]),matrix([-2,-1,1],[-1,-1,-1],[1,-1,-2]),matrix([-2,-1,1],[-1,-1,-1],[1,-1,-1]),matrix([-2,-1,1],[-1,-1,-1],[1,-1,2]),matrix([-2,-1,1],[-1,0,2],[1,2,0]),matrix([-2,-1,1],[-1,2,-2],[1,-2,2]),matrix([-2,-1,1],[-1,2,-1],[1,-1,1]),matrix([-2,-1,2],[-1,-2,2],[2,2,1]),matrix([-2,-1,2],[-1,0,-1],[2,-1,-2]),matrix([-2,-1,2],[-1,0,0],[2,0,-1]),matrix([-2,-1,2],[-1,0,1],[2,1,-2]),matrix([-2,0,1],[0,-2,1],[1,1,0]),matrix([-2,0,1],[0,-2,2],[1,2,-2])];

/* take a random ↑, and ?shuffle row/cols, ?multiply by -1 */
p:rand(permmats);
a:rand([-1,1])*p.rand(use_mats).transpose(p)+rand([-3,-2,-1,0,1,2,3])*ident(3);

/* get eigendata */
ee:eigenvectors(a);
eigvals:ee[1][1];
clear_denoms_list_getdenom(l):=block([varr],denom(ratsimp(l.makelist(varr[i],i,1,length(l)))));
clear_denoms_list(l):=clear_denoms_list_getdenom(l)*l;
eigvecs_raw:map(clear_denoms_list,lreduce(append,ee[2]));
eigvecs:map(lambda([l],simplify(transpose(matrix(l)))),eigvecs_raw);

/* helpers: assumes v1 and v2 are lists of the same length */
/* should be used when simp:false; */
dotprod_comp1(v1,v2):=matrix([ lreduce("+",map("*",v1,v2)) ]);
dotprod_comp2(v1,v2):=matrix([ lreduce("+",ev(map("*",v1,v2),simp,ratsimp)) ]);

/* preparation for printing the solution */
simp:false;
xy_comp1:dotprod_comp1(eigvecs_raw[1],eigvecs_raw[2]);
yz_comp1:dotprod_comp1(eigvecs_raw[2],eigvecs_raw[3]);
zx_comp1:dotprod_comp1(eigvecs_raw[3],eigvecs_raw[1]);
xy_comp2:dotprod_comp2(eigvecs_raw[1],eigvecs_raw[2]);
yz_comp2:dotprod_comp2(eigvecs_raw[2],eigvecs_raw[3]);
zx_comp2:dotprod_comp2(eigvecs_raw[3],eigvecs_raw[1]);
simp:true;
]]></text>
        </questionvariables>
        <specificfeedback format="html">
            <text></text>
        </specificfeedback>
        <questionnote>
            <text>\(A = {@a@}, \qquad X={@eigvecs[1]@},\qquad Y={@eigvecs[2]@},\qquad Z={@eigvecs[3]@}\)</text>
        </questionnote>
        <questionsimplify>1</questionsimplify>
        <assumepositive>0</assumepositive>
        <assumereal>0</assumereal>
        <prtcorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:green;">
    <i class="fa fa-check">
    </i>
</span>
Correct answer, well done.
]]></text>
        </prtcorrect>
        <prtpartiallycorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:orange;">
    <i class="fa fa-adjust">
    </i>
</span>
Your answer is partially correct.
]]></text>
        </prtpartiallycorrect>
        <prtincorrect format="html">
            <text><![CDATA[
<span style="font-size: 1.5em; color:red;">
    <i class="fa fa-times">
    </i>
</span>
Incorrect answer.
]]></text>
        </prtincorrect>
        <multiplicationsign>dot</multiplicationsign>
        <sqrtsign>1</sqrtsign>
        <complexno>i</complexno>
        <inversetrig>cos-1</inversetrig>
        <logicsymbol>lang</logicsymbol>
        <matrixparens>[</matrixparens>
        <variantsselectionseed></variantsselectionseed>
        <input>
            <name>ans_xy</name>
            <type>matrix</type>
            <tans>matrix([0])</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <input>
            <name>ans_yz</name>
            <type>matrix</type>
            <tans>matrix([0])</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <input>
            <name>ans_zx</name>
            <type>matrix</type>
            <tans>matrix([0])</tans>
            <boxsize>10</boxsize>
            <strictsyntax>1</strictsyntax>
            <insertstars>0</insertstars>
            <syntaxhint></syntaxhint>
            <syntaxattribute>0</syntaxattribute>
            <forbidwords></forbidwords>
            <allowwords></allowwords>
            <forbidfloat>1</forbidfloat>
            <requirelowestterms>0</requirelowestterms>
            <checkanswertype>0</checkanswertype>
            <mustverify>1</mustverify>
            <showvalidation>3</showvalidation>
            <options></options>
        </input>
        <prt>
            <name>prt_xy</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text></text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>AlgEquiv</answertest>
                <sans>ans_xy</sans>
                <tans>matrix([0])</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_xy-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_xy-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
        </prt>
        <prt>
            <name>prt_yz</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text></text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>AlgEquiv</answertest>
                <sans>ans_yz</sans>
                <tans>matrix([0])</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_yz-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_yz-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
        </prt>
        <prt>
            <name>prt_zx</name>
            <value>1.0000000</value>
            <autosimplify>1</autosimplify>
            <feedbackstyle>1</feedbackstyle>
            <feedbackvariables>
                <text></text>
            </feedbackvariables>
            <node>
                <name>0</name>
                <answertest>AlgEquiv</answertest>
                <sans>ans_zx</sans>
                <tans>matrix([0])</tans>
                <testoptions></testoptions>
                <quiet>0</quiet>
                <truescoremode>=</truescoremode>
                <truescore>1.0000000</truescore>
                <truepenalty></truepenalty>
                <truenextnode>-1</truenextnode>
                <trueanswernote>prt_zx-1-T</trueanswernote>
                <truefeedback format="html">
                    <text></text>
                </truefeedback>
                <falsescoremode>=</falsescoremode>
                <falsescore>0.0000000</falsescore>
                <falsepenalty></falsepenalty>
                <falsenextnode>-1</falsenextnode>
                <falseanswernote>prt_zx-1-F</falseanswernote>
                <falsefeedback format="html">
                    <text></text>
                </falsefeedback>
            </node>
        </prt>
        <deployedseed>427759454</deployedseed>
        <deployedseed>1007272107</deployedseed>
        <deployedseed>999811432</deployedseed>
        <deployedseed>305992961</deployedseed>
        <deployedseed>1090852261</deployedseed>
        <deployedseed>1687171120</deployedseed>
        <deployedseed>515563664</deployedseed>
        <deployedseed>1016999248</deployedseed>
        <deployedseed>1116772872</deployedseed>
        <deployedseed>5576100</deployedseed>
        <deployedseed>1472800365</deployedseed>
        <deployedseed>1059181732</deployedseed>
        <deployedseed>2120664713</deployedseed>
        <deployedseed>1329437341</deployedseed>
        <deployedseed>1211455186</deployedseed>
        <deployedseed>727339453</deployedseed>
        <deployedseed>561221400</deployedseed>
        <deployedseed>1914790856</deployedseed>
        <deployedseed>582147990</deployedseed>
        <deployedseed>739025649</deployedseed>
        <qtest>
            <testcase>1</testcase>
            <testinput>
                <name>ans_xy</name>
                <value>matrix([0])</value>
            </testinput>
            <testinput>
                <name>ans_yz</name>
                <value>matrix([0])</value>
            </testinput>
            <testinput>
                <name>ans_zx</name>
                <value>matrix([0])</value>
            </testinput>
            <expected>
                <name>prt_xy</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_xy-1-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_yz</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_yz-1-T</expectedanswernote>
            </expected>
            <expected>
                <name>prt_zx</name>
                <expectedscore>1.0000000</expectedscore>
                <expectedpenalty>0.0000000</expectedpenalty>
                <expectedanswernote>prt_zx-1-T</expectedanswernote>
            </expected>
        </qtest>
        <qtest>
            <testcase>2</testcase>
            <testinput>
                <name>ans_xy</name>
                <value>matrix([-1])</value>
            </testinput>
            <testinput>
                <name>ans_yz</name>
                <value>matrix([1])</value>
            </testinput>
            <testinput>
                <name>ans_zx</name>
                <value>matrix([1])</value>
            </testinput>
            <expected>
                <name>prt_xy</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_xy-1-F</expectedanswernote>
            </expected>
            <expected>
                <name>prt_yz</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_yz-1-F</expectedanswernote>
            </expected>
            <expected>
                <name>prt_zx</name>
                <expectedscore>0.0000000</expectedscore>
                <expectedpenalty>0.1000000</expectedpenalty>
                <expectedanswernote>prt_zx-1-F</expectedanswernote>
            </expected>
        </qtest>
    </question>
</quiz>
